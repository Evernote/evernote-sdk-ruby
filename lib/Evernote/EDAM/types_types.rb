#
# Autogenerated by Thrift Compiler (0.5.0-en-exported)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require 'limits_types'


module Evernote
  module EDAM
    module Type
      module PrivilegeLevel
        NORMAL = 1
        PREMIUM = 3
        VIP = 5
        MANAGER = 7
        SUPPORT = 8
        ADMIN = 9
        VALUE_MAP = {1 => "NORMAL", 3 => "PREMIUM", 5 => "VIP", 7 => "MANAGER", 8 => "SUPPORT", 9 => "ADMIN"}
        VALID_VALUES = Set.new([NORMAL, PREMIUM, VIP, MANAGER, SUPPORT, ADMIN]).freeze
      end

      module QueryFormat
        USER = 1
        SEXP = 2
        VALUE_MAP = {1 => "USER", 2 => "SEXP"}
        VALID_VALUES = Set.new([USER, SEXP]).freeze
      end

      module NoteSortOrder
        CREATED = 1
        UPDATED = 2
        RELEVANCE = 3
        UPDATE_SEQUENCE_NUMBER = 4
        TITLE = 5
        VALUE_MAP = {1 => "CREATED", 2 => "UPDATED", 3 => "RELEVANCE", 4 => "UPDATE_SEQUENCE_NUMBER", 5 => "TITLE"}
        VALID_VALUES = Set.new([CREATED, UPDATED, RELEVANCE, UPDATE_SEQUENCE_NUMBER, TITLE]).freeze
      end

      module PremiumOrderStatus
        NONE = 0
        PENDING = 1
        ACTIVE = 2
        FAILED = 3
        CANCELLATION_PENDING = 4
        CANCELED = 5
        VALUE_MAP = {0 => "NONE", 1 => "PENDING", 2 => "ACTIVE", 3 => "FAILED", 4 => "CANCELLATION_PENDING", 5 => "CANCELED"}
        VALID_VALUES = Set.new([NONE, PENDING, ACTIVE, FAILED, CANCELLATION_PENDING, CANCELED]).freeze
      end

      module SharedNotebookPrivilegeLevel
        READ_NOTEBOOK = 0
        MODIFY_NOTEBOOK_PLUS_ACTIVITY = 1
        READ_NOTEBOOK_PLUS_ACTIVITY = 2
        GROUP = 3
        FULL_ACCESS = 4
        BUSINESS_FULL_ACCESS = 5
        VALUE_MAP = {0 => "READ_NOTEBOOK", 1 => "MODIFY_NOTEBOOK_PLUS_ACTIVITY", 2 => "READ_NOTEBOOK_PLUS_ACTIVITY", 3 => "GROUP", 4 => "FULL_ACCESS", 5 => "BUSINESS_FULL_ACCESS"}
        VALID_VALUES = Set.new([READ_NOTEBOOK, MODIFY_NOTEBOOK_PLUS_ACTIVITY, READ_NOTEBOOK_PLUS_ACTIVITY, GROUP, FULL_ACCESS, BUSINESS_FULL_ACCESS]).freeze
      end

      module SponsoredGroupRole
        GROUP_MEMBER = 1
        GROUP_ADMIN = 2
        GROUP_OWNER = 3
        VALUE_MAP = {1 => "GROUP_MEMBER", 2 => "GROUP_ADMIN", 3 => "GROUP_OWNER"}
        VALID_VALUES = Set.new([GROUP_MEMBER, GROUP_ADMIN, GROUP_OWNER]).freeze
      end

      module BusinessUserRole
        ADMIN = 1
        NORMAL = 2
        VALUE_MAP = {1 => "ADMIN", 2 => "NORMAL"}
        VALID_VALUES = Set.new([ADMIN, NORMAL]).freeze
      end

      module SharedNotebookInstanceRestrictions
        ONLY_JOINED_OR_PREVIEW = 1
        NO_SHARED_NOTEBOOKS = 2
        VALUE_MAP = {1 => "ONLY_JOINED_OR_PREVIEW", 2 => "NO_SHARED_NOTEBOOKS"}
        VALID_VALUES = Set.new([ONLY_JOINED_OR_PREVIEW, NO_SHARED_NOTEBOOKS]).freeze
      end

      module ReminderEmailConfig
        DO_NOT_SEND = 1
        SEND_DAILY_EMAIL = 2
        VALUE_MAP = {1 => "DO_NOT_SEND", 2 => "SEND_DAILY_EMAIL"}
        VALID_VALUES = Set.new([DO_NOT_SEND, SEND_DAILY_EMAIL]).freeze
      end

      #  In several places, EDAM exchanges blocks of bytes of data for a component
#  which may be relatively large.  For example:  the contents of a clipped
#  HTML note, the bytes of an embedded image, or the recognition XML for
#  a large image.  This structure is used in the protocol to represent
#  any of those large blocks of data when they are transmitted or when
#  they are only referenced their metadata.
# 
# <dl>
#  <dt>bodyHash</dt>
#    <dd>This field carries a one-way hash of the contents of the
#    data body, in binary form.  The hash function is MD5<br/>
#    Length:  EDAM_HASH_LEN (exactly)
#    </dd>
# 
#  <dt>size</dt>
#    <dd>The length, in bytes, of the data body.
#    </dd>
# 
#  <dt>body</dt>
#    <dd>This field is set to contain the binary contents of the data
#    whenever the resource is being transferred.  If only metadata is
#    being exchanged, this field will be empty.  For example, a client could
#    notify the service about the change to an attribute for a resource
#    without transmitting the binary resource contents.
#    </dd>
#  </dl>
      class Data
        include ::Thrift::Struct, ::Thrift::Struct_Union
        BODYHASH = 1
        SIZE = 2
        BODY = 3

        FIELDS = {
          BODYHASH => {:type => ::Thrift::Types::STRING, :name => 'bodyHash', :binary => true, :optional => true},
          SIZE => {:type => ::Thrift::Types::I32, :name => 'size', :optional => true},
          BODY => {:type => ::Thrift::Types::STRING, :name => 'body', :binary => true, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      #  A structure holding the optional attributes that can be stored
#  on a User.  These are generally less critical than the core User fields.
# 
# <dl>
#  <dt>defaultLocationName</dt>
#    <dd>the location string that should be associated
#    with the user in order to determine where notes are taken if not otherwise
#    specified.<br/>
#    Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#    </dd>
# 
#  <dt>defaultLatitude</dt>
#    <dd>if set, this is the latitude that should be
#    assigned to any notes that have no other latitude information.
#    </dd>
# 
#  <dt>defaultLongitude</dt>
#    <dd>if set, this is the longitude that should be
#    assigned to any notes that have no other longitude information.
#    </dd>
# 
#  <dt>preactivation</dt>
#    <dd>if set, the user account is not yet confirmed for
#    login.  I.e. the account has been created, but we are still waiting for
#    the user to complete the activation step.
#    </dd>
# 
#  <dt>viewedPromotions</dt>
#    <dd>a list of promotions the user has seen.
#     This list may occasionally be modified by the system when promotions are
#     no longer available.<br/>
#     Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#    </dd>
# 
#  <dt>incomingEmailAddress</dt>
#    <dd>if set, this is the email address that the
#     user may send email to in order to add an email note directly into the
#     account via the SMTP email gateway.  This is the part of the email
#     address before the '@' symbol ... our domain is not included.
#     If this is not set, the user may not add notes via the gateway.<br/>
#     Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#    </dd>
# 
#  <dt>recentMailedAddresses</dt>
#    <dd>if set, this will contain a list of email
#     addresses that have recently been used as recipients
#     of outbound emails by the user.  This can be used to pre-populate a
#     list of possible destinations when a user wishes to send a note via
#     email.<br/>
#     Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX each<br/>
#     Max:  EDAM_USER_RECENT_MAILED_ADDRESSES_MAX entries
#    </dd>
# 
#  <dt>comments</dt>
#    <dd>Free-form text field that may hold general support
#     information, etc.<br/>
#     Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#    </dd>
# 
#  <dt>dateAgreedToTermsOfService</dt>
#    <dd>The date/time when the user agreed to
#     the terms of service.  This can be used as the effective "start date"
#     for the account.
#    </dd>
# 
#  <dt>maxReferrals</dt>
#    <dd>The number of referrals that the user is permitted
#     to make.
#    </dd>
# 
#  <dt>referralCount</dt>
#    <dd>The number of referrals sent from this account.
#    </dd>
# 
#  <dt>refererCode</dt>
#    <dd>A code indicating where the user was sent from. AKA
#     promotion code
#    </dd>
# 
#  <dt>sentEmailDate</dt>
#    <dd>The most recent date when the user sent outbound
#     emails from the service.  Used with sentEmailCount to limit the number
#     of emails that can be sent per day.
#    </dd>
# 
#  <dt>sentEmailCount</dt>
#    <dd>The number of emails that were sent from the user
#     via the service on sentEmailDate.  Used to enforce a limit on the number
#     of emails per user per day to prevent spamming.
#    </dd>
# 
#  <dt>dailyEmailLimit</dt>
#    <dd>If set, this is the maximum number of emails that
#     may be sent in a given day from this account.  If unset, the server will
#     use the configured default limit.
#    </dd>
# 
#  <dt>emailOptOutDate</dt>
#    <dd>If set, this is the date when the user asked
#     to be excluded from offers and promotions sent by Evernote.  If not set,
#     then the user currently agrees to receive these messages.
#    </dd>
# 
#  <dt>partnerEmailOptInDate</dt>
#    <dd>If set, this is the date when the user asked
#     to be included in offers and promotions sent by Evernote's partners.
#     If not sent, then the user currently does not agree to receive these
#     emails.
#    </dd>
# 
#  <dt>preferredLanguage</dt>
#    <dd>a 2 character language codes based on:
#        http://ftp.ics.uci.edu/pub/ietf/http/related/iso639.txt used for
#       localization purposes to determine what language to use for the web
#       interface and for other direct communication (e.g. emails).
#    </dd>
# 
#  <dt>preferredCountry</dt>
#    <dd>Preferred country code based on ISO 3166-1-alpha-2 indicating the
#    users preferred country</dd>
# 
#  <dt>clipFullPage</dt>
#    <dd>Boolean flag set to true if the user wants to clip full pages by
#    default when they use the web clipper without a selection.</dd>
# 
#  <dt>twitterUserName</dt>
#    <dd>The username of the account of someone who has chosen to enable
#    Twittering into Evernote.  This value is subject to change, since users
#    may change their Twitter user name.</dd>
# 
#  <dt>twitterId</dt>
#    <dd>The unique identifier of the user's Twitter account if that user
#    has chosen to enable Twittering into Evernote.</dd>
# 
#  <dt>groupName</dt>
#    <dd>A name identifier used to identify a particular set of branding and
#     light customization.</dd>
# 
#  <dt>recognitionLanguage</dt>
#    <dd>a 2 character language codes based on:
#        http://ftp.ics.uci.edu/pub/ietf/http/related/iso639.txt
#        If set, this is used to determine the language that should be used
#        when processing images and PDF files to find text.
#        If not set, then the 'preferredLanguage' will be used.
#    </dd>
# 
#  <dt>educationalInstitution</dt>
#    <dd>a flag indicating that the user is part of an educational institution which
#    makes them eligible for discounts on bulk purchases
#    </dd>
# 
#  <dt>businessAddress</dt>
#    <dd>A string recording the business address of a Sponsored Account user who has requested invoicing.
#    </dd>
# 
#  <dt>hideSponsorBilling</dt>
#    <dd>A flag indicating whether to hide the billing information on a sponsored
#        account owner's settings page
#    </dd>
# 
#  <dt>taxExempt</dt>
#    <dd>A flag indicating the user's sponsored group is exempt from sale tax
#    </dd>
# 
#  <dt>useEmailAutoFiling</dt>
#    <dd>A flag indicating whether the user chooses to allow Evernote to automatically
#        file and tag emailed notes
#    </dd>
# 
#  <dt>reminderEmailConfig</dt>
#    <dd>Configuration state for whether or not the user wishes to receive
#        reminder e-mail.  This setting applies to both the reminder e-mail sent
#        for personal reminder notes and for the reminder e-mail sent for reminder
#        notes in the user's business notebooks that the user has configured for
#        e-mail notifications.
#    </dd>
#  </dl>
      class UserAttributes
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DEFAULTLOCATIONNAME = 1
        DEFAULTLATITUDE = 2
        DEFAULTLONGITUDE = 3
        PREACTIVATION = 4
        VIEWEDPROMOTIONS = 5
        INCOMINGEMAILADDRESS = 6
        RECENTMAILEDADDRESSES = 7
        COMMENTS = 9
        DATEAGREEDTOTERMSOFSERVICE = 11
        MAXREFERRALS = 12
        REFERRALCOUNT = 13
        REFERERCODE = 14
        SENTEMAILDATE = 15
        SENTEMAILCOUNT = 16
        DAILYEMAILLIMIT = 17
        EMAILOPTOUTDATE = 18
        PARTNEREMAILOPTINDATE = 19
        PREFERREDLANGUAGE = 20
        PREFERREDCOUNTRY = 21
        CLIPFULLPAGE = 22
        TWITTERUSERNAME = 23
        TWITTERID = 24
        GROUPNAME = 25
        RECOGNITIONLANGUAGE = 26
        REFERRALPROOF = 28
        EDUCATIONALDISCOUNT = 29
        BUSINESSADDRESS = 30
        HIDESPONSORBILLING = 31
        TAXEXEMPT = 32
        USEEMAILAUTOFILING = 33
        REMINDEREMAILCONFIG = 34

        FIELDS = {
          DEFAULTLOCATIONNAME => {:type => ::Thrift::Types::STRING, :name => 'defaultLocationName', :optional => true},
          DEFAULTLATITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'defaultLatitude', :optional => true},
          DEFAULTLONGITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'defaultLongitude', :optional => true},
          PREACTIVATION => {:type => ::Thrift::Types::BOOL, :name => 'preactivation', :optional => true},
          VIEWEDPROMOTIONS => {:type => ::Thrift::Types::LIST, :name => 'viewedPromotions', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          INCOMINGEMAILADDRESS => {:type => ::Thrift::Types::STRING, :name => 'incomingEmailAddress', :optional => true},
          RECENTMAILEDADDRESSES => {:type => ::Thrift::Types::LIST, :name => 'recentMailedAddresses', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          COMMENTS => {:type => ::Thrift::Types::STRING, :name => 'comments', :optional => true},
          DATEAGREEDTOTERMSOFSERVICE => {:type => ::Thrift::Types::I64, :name => 'dateAgreedToTermsOfService', :optional => true},
          MAXREFERRALS => {:type => ::Thrift::Types::I32, :name => 'maxReferrals', :optional => true},
          REFERRALCOUNT => {:type => ::Thrift::Types::I32, :name => 'referralCount', :optional => true},
          REFERERCODE => {:type => ::Thrift::Types::STRING, :name => 'refererCode', :optional => true},
          SENTEMAILDATE => {:type => ::Thrift::Types::I64, :name => 'sentEmailDate', :optional => true},
          SENTEMAILCOUNT => {:type => ::Thrift::Types::I32, :name => 'sentEmailCount', :optional => true},
          DAILYEMAILLIMIT => {:type => ::Thrift::Types::I32, :name => 'dailyEmailLimit', :optional => true},
          EMAILOPTOUTDATE => {:type => ::Thrift::Types::I64, :name => 'emailOptOutDate', :optional => true},
          PARTNEREMAILOPTINDATE => {:type => ::Thrift::Types::I64, :name => 'partnerEmailOptInDate', :optional => true},
          PREFERREDLANGUAGE => {:type => ::Thrift::Types::STRING, :name => 'preferredLanguage', :optional => true},
          PREFERREDCOUNTRY => {:type => ::Thrift::Types::STRING, :name => 'preferredCountry', :optional => true},
          CLIPFULLPAGE => {:type => ::Thrift::Types::BOOL, :name => 'clipFullPage', :optional => true},
          TWITTERUSERNAME => {:type => ::Thrift::Types::STRING, :name => 'twitterUserName', :optional => true},
          TWITTERID => {:type => ::Thrift::Types::STRING, :name => 'twitterId', :optional => true},
          GROUPNAME => {:type => ::Thrift::Types::STRING, :name => 'groupName', :optional => true},
          RECOGNITIONLANGUAGE => {:type => ::Thrift::Types::STRING, :name => 'recognitionLanguage', :optional => true},
          REFERRALPROOF => {:type => ::Thrift::Types::STRING, :name => 'referralProof', :optional => true},
          EDUCATIONALDISCOUNT => {:type => ::Thrift::Types::BOOL, :name => 'educationalDiscount', :optional => true},
          BUSINESSADDRESS => {:type => ::Thrift::Types::STRING, :name => 'businessAddress', :optional => true},
          HIDESPONSORBILLING => {:type => ::Thrift::Types::BOOL, :name => 'hideSponsorBilling', :optional => true},
          TAXEXEMPT => {:type => ::Thrift::Types::BOOL, :name => 'taxExempt', :optional => true},
          USEEMAILAUTOFILING => {:type => ::Thrift::Types::BOOL, :name => 'useEmailAutoFiling', :optional => true},
          REMINDEREMAILCONFIG => {:type => ::Thrift::Types::I32, :name => 'reminderEmailConfig', :optional => true, :enum_class => ::Evernote::EDAM::Type::ReminderEmailConfig}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @reminderEmailConfig.nil? || ::Evernote::EDAM::Type::ReminderEmailConfig::VALID_VALUES.include?(@reminderEmailConfig)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field reminderEmailConfig!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      #  This represents the bookkeeping information for the user's subscription.
# 
# <dl>
#  <dt>uploadLimit</dt>
#    <dd>The number of bytes that can be uploaded to the account
#    in the current month.  For new notes that are created, this is the length
#    of the note content (in Unicode characters) plus the size of each resource
#    (in bytes).  For edited notes, this is the the difference between the old
#    length and the new length (if this is greater than 0) plus the size of
#    each new resource.
#    </dd>
#  <dt>uploadLimitEnd</dt>
#    <dd>The date and time when the current upload limit
#    expires.  At this time, the monthly upload count reverts to 0 and a new
#    limit is imposed.  This date and time is exclusive, so this is effectively
#    the start of the new month.
#    </dd>
#  <dt>uploadLimitNextMonth</dt>
#    <dd> When uploadLimitEnd is reached, the service
#    will change uploadLimit to uploadLimitNextMonth. If a premium account is
#    canceled, this mechanism will reset the quota appropriately.
#    </dd>
#  <dt>premiumServiceStatus</dt>
#    <dd>Indicates the phases of a premium account
#    during the billing process.
#    </dd>
#  <dt>premiumOrderNumber</dt>
#    <dd>The order number used by the commerce system to
#    process recurring payments
#    </dd>
#  <dt>premiumServiceStart</dt>
#    <dd>The start date when this premium promotion
#    began (this number will get overwritten if a premium service is canceled
#    and then re-activated).
#    </dd>
#  <dt>premiumCommerceService</dt>
#    <dd>The commerce system used (paypal, Google
#    checkout, etc)
#    </dd>
#  <dt>premiumServiceSKU</dt>
#    <dd>The code associated with the purchase eg. monthly
#    or annual purchase. Clients should interpret this value and localize it.
#    </dd>
#  <dt>lastSuccessfulCharge</dt>
#    <dd>Date the last time the user was charged.
#    Null if never charged.
#    </dd>
#  <dt>lastFailedCharge</dt>
#    <dd>Date the last time a charge was attempted and
#    failed.
#    </dd>
#  <dt>lastFailedChargeReason</dt>
#    <dd>Reason provided for the charge failure
#    </dd>
#  <dt>nextPaymentDue</dt>
#    <dd>The end of the billing cycle. This could be in the
#    past if there are failed charges.
#    </dd>
#  <dt>premiumLockUntil</dt>
#    <dd>An internal variable to manage locking operations
#    on the commerce variables.
#    </dd>
#  <dt>updated</dt>
#    <dd>The date any modification where made to this record.
#    </dd>
#  <dt>premiumSubscriptionNumber</dt>
#    <dd>The number number identifying the
#    recurring subscription used to make the recurring charges.
#    </dd>
#  <dt>lastRequestedCharge</dt>
#    <dd>Date charge last attempted</dd>
#  <dt>currency</dt>
#    <dd>ISO 4217 currency code</dd>
#  <dt>unitPrice</dt>
#    <dd>charge in the smallest unit of the currency (e.g. cents for USD)</dd>
#  <dt>businessId</dt>
#    <dd><i>DEPRECATED:</i>See BusinessUserInfo.</dd>
#  <dt>businessName</dt>
#    <dd><i>DEPRECATED:</i>See BusinessUserInfo.</dd>
#  <dt>businessRole</dt>
#    <dd><i>DEPRECATED:</i>See BusinessUserInfo.</dd>
#  <dt>unitDiscount</dt>
#    <dd>discount per seat in negative amount and smallest unit of the currency (e.g. cents for USD)</dd>
#  <dt>nextChargeDate</dt>
#    <dd>The next time the user will be charged, may or may not be the same as nextPaymentDue</dd>
#  </dl>
      class Accounting
        include ::Thrift::Struct, ::Thrift::Struct_Union
        UPLOADLIMIT = 1
        UPLOADLIMITEND = 2
        UPLOADLIMITNEXTMONTH = 3
        PREMIUMSERVICESTATUS = 4
        PREMIUMORDERNUMBER = 5
        PREMIUMCOMMERCESERVICE = 6
        PREMIUMSERVICESTART = 7
        PREMIUMSERVICESKU = 8
        LASTSUCCESSFULCHARGE = 9
        LASTFAILEDCHARGE = 10
        LASTFAILEDCHARGEREASON = 11
        NEXTPAYMENTDUE = 12
        PREMIUMLOCKUNTIL = 13
        UPDATED = 14
        PREMIUMSUBSCRIPTIONNUMBER = 16
        LASTREQUESTEDCHARGE = 17
        CURRENCY = 18
        UNITPRICE = 19
        BUSINESSID = 20
        BUSINESSNAME = 21
        BUSINESSROLE = 22
        UNITDISCOUNT = 23
        NEXTCHARGEDATE = 24

        FIELDS = {
          UPLOADLIMIT => {:type => ::Thrift::Types::I64, :name => 'uploadLimit', :optional => true},
          UPLOADLIMITEND => {:type => ::Thrift::Types::I64, :name => 'uploadLimitEnd', :optional => true},
          UPLOADLIMITNEXTMONTH => {:type => ::Thrift::Types::I64, :name => 'uploadLimitNextMonth', :optional => true},
          PREMIUMSERVICESTATUS => {:type => ::Thrift::Types::I32, :name => 'premiumServiceStatus', :optional => true, :enum_class => ::Evernote::EDAM::Type::PremiumOrderStatus},
          PREMIUMORDERNUMBER => {:type => ::Thrift::Types::STRING, :name => 'premiumOrderNumber', :optional => true},
          PREMIUMCOMMERCESERVICE => {:type => ::Thrift::Types::STRING, :name => 'premiumCommerceService', :optional => true},
          PREMIUMSERVICESTART => {:type => ::Thrift::Types::I64, :name => 'premiumServiceStart', :optional => true},
          PREMIUMSERVICESKU => {:type => ::Thrift::Types::STRING, :name => 'premiumServiceSKU', :optional => true},
          LASTSUCCESSFULCHARGE => {:type => ::Thrift::Types::I64, :name => 'lastSuccessfulCharge', :optional => true},
          LASTFAILEDCHARGE => {:type => ::Thrift::Types::I64, :name => 'lastFailedCharge', :optional => true},
          LASTFAILEDCHARGEREASON => {:type => ::Thrift::Types::STRING, :name => 'lastFailedChargeReason', :optional => true},
          NEXTPAYMENTDUE => {:type => ::Thrift::Types::I64, :name => 'nextPaymentDue', :optional => true},
          PREMIUMLOCKUNTIL => {:type => ::Thrift::Types::I64, :name => 'premiumLockUntil', :optional => true},
          UPDATED => {:type => ::Thrift::Types::I64, :name => 'updated', :optional => true},
          PREMIUMSUBSCRIPTIONNUMBER => {:type => ::Thrift::Types::STRING, :name => 'premiumSubscriptionNumber', :optional => true},
          LASTREQUESTEDCHARGE => {:type => ::Thrift::Types::I64, :name => 'lastRequestedCharge', :optional => true},
          CURRENCY => {:type => ::Thrift::Types::STRING, :name => 'currency', :optional => true},
          UNITPRICE => {:type => ::Thrift::Types::I32, :name => 'unitPrice', :optional => true},
          BUSINESSID => {:type => ::Thrift::Types::I32, :name => 'businessId', :optional => true},
          BUSINESSNAME => {:type => ::Thrift::Types::STRING, :name => 'businessName', :optional => true},
          BUSINESSROLE => {:type => ::Thrift::Types::I32, :name => 'businessRole', :optional => true, :enum_class => ::Evernote::EDAM::Type::BusinessUserRole},
          UNITDISCOUNT => {:type => ::Thrift::Types::I32, :name => 'unitDiscount', :optional => true},
          NEXTCHARGEDATE => {:type => ::Thrift::Types::I64, :name => 'nextChargeDate', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @premiumServiceStatus.nil? || ::Evernote::EDAM::Type::PremiumOrderStatus::VALID_VALUES.include?(@premiumServiceStatus)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field premiumServiceStatus!')
          end
          unless @businessRole.nil? || ::Evernote::EDAM::Type::BusinessUserRole::VALID_VALUES.include?(@businessRole)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field businessRole!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # This structure is used to provide information about an Evernote Business
# membership, for members who are part of a business.
# 
# <dl>
# <dt>businessId</dt>
#   <dd>The ID of the Evernote Business account that the user is a member of.
# <dt>businessName</dt>
#   <dd>The human-readable name of the Evernote Business account that the user
#       is a member of.</dd>
# <dt>role</dt>
#   <dd>The role of the user within the Evernote Business account that
#       they are a member of.</dd>
# <dt>email</dt>
#   <dd>An e-mail address that will be used by the service in the context of your
#       Evernote Business activities.  For example, this e-mail address will be used
#       when you e-mail a business note, when you update notes in the account of
#       your business, etc.  The business e-mail cannot be used for identification
#       purposes such as for logging into the service.
#   </dd>
# </dl>
      class BusinessUserInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        BUSINESSID = 1
        BUSINESSNAME = 2
        ROLE = 3
        EMAIL = 4

        FIELDS = {
          BUSINESSID => {:type => ::Thrift::Types::I32, :name => 'businessId', :optional => true},
          BUSINESSNAME => {:type => ::Thrift::Types::STRING, :name => 'businessName', :optional => true},
          ROLE => {:type => ::Thrift::Types::I32, :name => 'role', :optional => true, :enum_class => ::Evernote::EDAM::Type::BusinessUserRole},
          EMAIL => {:type => ::Thrift::Types::STRING, :name => 'email', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @role.nil? || ::Evernote::EDAM::Type::BusinessUserRole::VALID_VALUES.include?(@role)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field role!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      #  This structure is used to provide information about a user's Premium account.
# <dl>
#  <dt>currentTime</dt>
#    <dd>
#    The server-side date and time when this data was generated.
#    </dd>
#  <dt>premium</dt>
#    <dd>
#    True if the user's account is Premium.
#    </dd>
#  <dt>premiumRecurring</dt>
#    <dd>
#    True if the user's account is Premium and has a recurring payment method.
#    </dd>
#  <dt>premiumExpirationDate</dt>
#    <dd>
#    The date when the user's Premium account expires, or the date when the
#    user's account is due for payment if it has a recurring payment method.
#    </dd>
#  <dt>premiumExtendable</dt>
#    <dd>
#    True if the user is eligible for purchasing Premium account extensions.
#    </dd>
#  <dt>premiumPending</dt>
#    <dd>
#    True if the user's Premium account is pending payment confirmation
#    </dd>
#  <dt>premiumCancellationPending</dt>
#    <dd>
#    True if the user has requested that no further charges to be made; the
#    Premium account will remain active until it expires.
#    </dd>
#  <dt>canPurchaseUploadAllowance</dt>
#    <dd>
#    True if the user is eligible for purchasing additional upload allowance.
#    </dd>
#  <dt>sponsoredGroupName</dt>
#    <dd>
#    The name of the sponsored group that the user is part of.
#    </dd>
#  <dt>sponsoredGroupRole</dt>
#    <dd>
#    DEPRECATED - will be removed in a future update.
#    </dd>
#  <dt>premiumUpgradable</dt>
#    <dd>
#    True if the user is eligible for purchasing Premium account upgrade.
#    </dd>
#  </dl>
      class PremiumInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CURRENTTIME = 1
        PREMIUM = 2
        PREMIUMRECURRING = 3
        PREMIUMEXPIRATIONDATE = 4
        PREMIUMEXTENDABLE = 5
        PREMIUMPENDING = 6
        PREMIUMCANCELLATIONPENDING = 7
        CANPURCHASEUPLOADALLOWANCE = 8
        SPONSOREDGROUPNAME = 9
        SPONSOREDGROUPROLE = 10
        PREMIUMUPGRADABLE = 11

        FIELDS = {
          CURRENTTIME => {:type => ::Thrift::Types::I64, :name => 'currentTime'},
          PREMIUM => {:type => ::Thrift::Types::BOOL, :name => 'premium'},
          PREMIUMRECURRING => {:type => ::Thrift::Types::BOOL, :name => 'premiumRecurring'},
          PREMIUMEXPIRATIONDATE => {:type => ::Thrift::Types::I64, :name => 'premiumExpirationDate', :optional => true},
          PREMIUMEXTENDABLE => {:type => ::Thrift::Types::BOOL, :name => 'premiumExtendable'},
          PREMIUMPENDING => {:type => ::Thrift::Types::BOOL, :name => 'premiumPending'},
          PREMIUMCANCELLATIONPENDING => {:type => ::Thrift::Types::BOOL, :name => 'premiumCancellationPending'},
          CANPURCHASEUPLOADALLOWANCE => {:type => ::Thrift::Types::BOOL, :name => 'canPurchaseUploadAllowance'},
          SPONSOREDGROUPNAME => {:type => ::Thrift::Types::STRING, :name => 'sponsoredGroupName', :optional => true},
          SPONSOREDGROUPROLE => {:type => ::Thrift::Types::I32, :name => 'sponsoredGroupRole', :optional => true, :enum_class => ::Evernote::EDAM::Type::SponsoredGroupRole},
          PREMIUMUPGRADABLE => {:type => ::Thrift::Types::BOOL, :name => 'premiumUpgradable', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field currentTime is unset!') unless @currentTime
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field premium is unset!') if @premium.nil?
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field premiumRecurring is unset!') if @premiumRecurring.nil?
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field premiumExtendable is unset!') if @premiumExtendable.nil?
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field premiumPending is unset!') if @premiumPending.nil?
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field premiumCancellationPending is unset!') if @premiumCancellationPending.nil?
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field canPurchaseUploadAllowance is unset!') if @canPurchaseUploadAllowance.nil?
          unless @sponsoredGroupRole.nil? || ::Evernote::EDAM::Type::SponsoredGroupRole::VALID_VALUES.include?(@sponsoredGroupRole)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field sponsoredGroupRole!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      #  This represents the information about a single user account.
# <dl>
#  <dt>id</dt>
#    <dd>The unique numeric identifier for the account, which will not
#    change for the lifetime of the account.
#    </dd>
# 
#  <dt>username</dt>
#    <dd>The name that uniquely identifies a single user account. This name
#    may be presented by the user, along with their password, to log into
#    their account.
#    May only contain a-z, 0-9, or '-', and may not start or end with the '-'
#    <br/>
#    Length:  EDAM_USER_USERNAME_LEN_MIN - EDAM_USER_USERNAME_LEN_MAX
#    <br/>
#    Regex:  EDAM_USER_USERNAME_REGEX
#    </dd>
# 
#  <dt>email</dt>
#    <dd>The email address registered for the user.  Must comply with
#    RFC 2821 and RFC 2822.<br/>
#    Third party applications that authenticate using OAuth do not have
#    access to this field.
#    Length:  EDAM_EMAIL_LEN_MIN - EDAM_EMAIL_LEN_MAX
#    <br/>
#    Regex:  EDAM_EMAIL_REGEX
#    </dd>
# 
#  <dt>name</dt>
#    <dd>The printable name of the user, which may be a combination
#    of given and family names.  This is used instead of separate "first"
#    and "last" names due to variations in international name format/order.
#    May not start or end with a whitespace character.  May contain any
#    character but carriage return or newline (Unicode classes Zl and Zp).
#    <br/>
#    Length:  EDAM_USER_NAME_LEN_MIN - EDAM_USER_NAME_LEN_MAX
#    <br/>
#    Regex:  EDAM_USER_NAME_REGEX
#    </dd>
# 
#  <dt>timezone</dt>
#    <dd>The zone ID for the user's default location.  If present,
#    this may be used to localize the display of any timestamp for which no
#    other timezone is available.
#    The format must be encoded as a standard zone ID such as
#    "America/Los_Angeles" or "GMT+08:00"
#    <br/>
#    Length:  EDAM_TIMEZONE_LEN_MIN - EDAM_TIMEZONE_LEN_MAX
#    <br/>
#    Regex:  EDAM_TIMEZONE_REGEX
#    </dd>
# 
#  <dt>privilege</dt>
#    <dd>The level of access permitted for the user.
#    </dd>
# 
#  <dt>created</dt>
#    <dd>The date and time when this user account was created in the
#    service.
#    </dd>
# 
#  <dt>updated</dt>
#    <dd>The date and time when this user account was last modified
#    in the service.
#    </dd>
# 
#  <dt>deleted</dt>
#    <dd>If the account has been deleted from the system (e.g. as
#    the result of a legal request by the user), the date and time of the
#    deletion will be represented here.  If not, this value will not be set.
#    </dd>
# 
#  <dt>active</dt>
#    <dd>If the user account is available for login and
#    synchronization, this flag will be set to true.
#    </dd>
# 
#  <dt>shardId</dt>
#    <dd>DEPRECATED - Client applications should have no need to use this field.
#    </dd>
# 
#  <dt>attributes</dt>
#    <dd>If present, this will contain a list of the attributes
#    for this user account.
#    </dd>
# 
#  <dt>accounting</dt>
#    <dd>Bookkeeping information for the user's subscription.
#    </dd>
# 
#  <dt>premiumInfo</dt>
#    <dd>If present, this will contain a set of commerce information
#    relating to the user's premium service level.
#    </dd>
# 
#  <dt>businessUserInfo</dt>
#    <dd>If present, this will contain a set of business information
#    relating to the user's business membership.  If not present, the
#    user is not currently part of a business.
#    </dd>
#  </dl>
      class User
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ID = 1
        USERNAME = 2
        EMAIL = 3
        NAME = 4
        TIMEZONE = 6
        PRIVILEGE = 7
        CREATED = 9
        UPDATED = 10
        DELETED = 11
        ACTIVE = 13
        SHARDID = 14
        ATTRIBUTES = 15
        ACCOUNTING = 16
        PREMIUMINFO = 17
        BUSINESSUSERINFO = 18

        FIELDS = {
          ID => {:type => ::Thrift::Types::I32, :name => 'id', :optional => true},
          USERNAME => {:type => ::Thrift::Types::STRING, :name => 'username', :optional => true},
          EMAIL => {:type => ::Thrift::Types::STRING, :name => 'email', :optional => true},
          NAME => {:type => ::Thrift::Types::STRING, :name => 'name', :optional => true},
          TIMEZONE => {:type => ::Thrift::Types::STRING, :name => 'timezone', :optional => true},
          PRIVILEGE => {:type => ::Thrift::Types::I32, :name => 'privilege', :optional => true, :enum_class => ::Evernote::EDAM::Type::PrivilegeLevel},
          CREATED => {:type => ::Thrift::Types::I64, :name => 'created', :optional => true},
          UPDATED => {:type => ::Thrift::Types::I64, :name => 'updated', :optional => true},
          DELETED => {:type => ::Thrift::Types::I64, :name => 'deleted', :optional => true},
          ACTIVE => {:type => ::Thrift::Types::BOOL, :name => 'active', :optional => true},
          SHARDID => {:type => ::Thrift::Types::STRING, :name => 'shardId', :optional => true},
          ATTRIBUTES => {:type => ::Thrift::Types::STRUCT, :name => 'attributes', :class => ::Evernote::EDAM::Type::UserAttributes, :optional => true},
          ACCOUNTING => {:type => ::Thrift::Types::STRUCT, :name => 'accounting', :class => ::Evernote::EDAM::Type::Accounting, :optional => true},
          PREMIUMINFO => {:type => ::Thrift::Types::STRUCT, :name => 'premiumInfo', :class => ::Evernote::EDAM::Type::PremiumInfo, :optional => true},
          BUSINESSUSERINFO => {:type => ::Thrift::Types::STRUCT, :name => 'businessUserInfo', :class => ::Evernote::EDAM::Type::BusinessUserInfo, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @privilege.nil? || ::Evernote::EDAM::Type::PrivilegeLevel::VALID_VALUES.include?(@privilege)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field privilege!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      #  A tag within a user's account is a unique name which may be organized
#  a simple hierarchy.
# <dl>
#  <dt>guid</dt>
#    <dd>The unique identifier of this tag. Will be set by the service,
#    so may be omitted by the client when creating the Tag.
#    <br/>
#    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
#    <br/>
#    Regex:  EDAM_GUID_REGEX
#    </dd>
# 
#  <dt>name</dt>
#    <dd>A sequence of characters representing the tag's identifier.
#    Case is preserved, but is ignored for comparisons.
#    This means that an account may only have one tag with a given name, via
#    case-insensitive comparison, so an account may not have both "food" and
#    "Food" tags.
#    May not contain a comma (','), and may not begin or end with a space.
#    <br/>
#    Length:  EDAM_TAG_NAME_LEN_MIN - EDAM_TAG_NAME_LEN_MAX
#    <br/>
#    Regex:  EDAM_TAG_NAME_REGEX
#    </dd>
# 
#  <dt>parentGuid</dt>
#    <dd>If this is set, then this is the GUID of the tag that
#    holds this tag within the tag organizational hierarchy.  If this is
#    not set, then the tag has no parent and it is a "top level" tag.
#    Cycles are not allowed (e.g. a->parent->parent == a) and will be
#    rejected by the service.
#    <br/>
#    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
#    <br/>
#    Regex:  EDAM_GUID_REGEX
#    </dd>
# 
#  <dt>updateSequenceNum</dt>
#    <dd>A number identifying the last transaction to
#    modify the state of this object.  The USN values are sequential within an
#    account, and can be used to compare the order of modifications within the
#    service.
#    </dd>
#  </dl>
      class Tag
        include ::Thrift::Struct, ::Thrift::Struct_Union
        GUID = 1
        NAME = 2
        PARENTGUID = 3
        UPDATESEQUENCENUM = 4

        FIELDS = {
          GUID => {:type => ::Thrift::Types::STRING, :name => 'guid', :optional => true},
          NAME => {:type => ::Thrift::Types::STRING, :name => 'name', :optional => true},
          PARENTGUID => {:type => ::Thrift::Types::STRING, :name => 'parentGuid', :optional => true},
          UPDATESEQUENCENUM => {:type => ::Thrift::Types::I32, :name => 'updateSequenceNum', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A structure that wraps a map of name/value pairs whose values are not
# always present in the structure in order to reduce space when obtaining
# batches of entities that contain the map.
# 
# When the server provides the client with a LazyMap, it will fill in either
# the keysOnly field or the fullMap field, but never both, based on the API
# and parameters.
# 
# When a client provides a LazyMap to the server as part of an update to
# an object, the server will only update the LazyMap if the fullMap field is
# set. If the fullMap field is not set, the server will not make any changes
# to the map.
# 
# Check the API documentation of the individual calls involving the LazyMap
# for full details including the constraints of the names and values of the
# map.
# 
# <dl>
# <dt>keysOnly</dt>
#   <dd>The set of keys for the map.  This field is ignored by the
#       server when set.
#   </dd>
# 
# <dt>fullMap</dt>
#   <dd>The complete map, including all keys and values.
#   </dd>
# </dl>
      class LazyMap
        include ::Thrift::Struct, ::Thrift::Struct_Union
        KEYSONLY = 1
        FULLMAP = 2

        FIELDS = {
          KEYSONLY => {:type => ::Thrift::Types::SET, :name => 'keysOnly', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          FULLMAP => {:type => ::Thrift::Types::MAP, :name => 'fullMap', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Structure holding the optional attributes of a Resource
# <dl>
# <dt>sourceURL</dt>
#   <dd>the original location where the resource was hosted
#   <br/>
#    Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#   </dd>
# 
# <dt>timestamp</dt>
#   <dd>the date and time that is associated with this resource
#   (e.g. the time embedded in an image from a digital camera with a clock)
#   </dd>
# 
# <dt>latitude</dt>
#   <dd>the latitude where the resource was captured
#   </dd>
# 
# <dt>longitude</dt>
#   <dd>the longitude where the resource was captured
#   </dd>
# 
# <dt>altitude</dt>
#   <dd>the altitude where the resource was captured
#   </dd>
# 
# <dt>cameraMake</dt>
#   <dd>information about an image's camera, e.g. as embedded in
#   the image's EXIF data
#   <br/>
#   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#   </dd>
# 
# <dt>cameraModel</dt>
#   <dd>information about an image's camera, e.g. as embedded
#   in the image's EXIF data
#   <br/>
#   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#   </dd>
# 
# <dt>clientWillIndex</dt>
#   <dd>if true, then the original client that submitted
#   the resource plans to submit the recognition index for this resource at a
#   later time.
#   </dd>
# 
# <dt>recoType</dt>
#   <dd>DEPRECATED - this field is no longer set by the service, so should
#     be ignored.
#   </dd>
# 
# <dt>fileName</dt>
#   <dd>if the resource came from a source that provided an
#   explicit file name, the original name will be stored here.  Many resources
#   come from unnamed sources, so this will not always be set.
#   </dd>
# 
# <dt>attachment</dt>
#   <dd>this will be true if the resource should be displayed as an attachment,
#   or false if the resource should be displayed inline (if possible).
#   </dd>
# 
# <dt>applicationData</dt>
# <dd>Provides a location for applications to store a relatively small
# (4kb) blob of data associated with a Resource that is not visible to the user
# and that is opaque to the Evernote service. A single application may use at most
# one entry in this map, using its API consumer key as the map key. See the
# documentation for LazyMap for a description of when the actual map values
# are returned by the service.
# <p>To safely add or modify your application's entry in the map, use
# NoteStore.setResourceApplicationDataEntry. To safely remove your application's
# entry from the map, use NoteStore.unsetResourceApplicationDataEntry.</p>
# Minimum length of a name (key): EDAM_APPLICATIONDATA_NAME_LEN_MIN
# <br/>
# Sum max size of key and value: EDAM_APPLICATIONDATA_ENTRY_LEN_MAX
# <br/>
# Syntax regex for name (key): EDAM_APPLICATIONDATA_NAME_REGEX
# </dd>
# 
# </dl>
      class ResourceAttributes
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SOURCEURL = 1
        TIMESTAMP = 2
        LATITUDE = 3
        LONGITUDE = 4
        ALTITUDE = 5
        CAMERAMAKE = 6
        CAMERAMODEL = 7
        CLIENTWILLINDEX = 8
        RECOTYPE = 9
        FILENAME = 10
        ATTACHMENT = 11
        APPLICATIONDATA = 12

        FIELDS = {
          SOURCEURL => {:type => ::Thrift::Types::STRING, :name => 'sourceURL', :optional => true},
          TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp', :optional => true},
          LATITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'latitude', :optional => true},
          LONGITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'longitude', :optional => true},
          ALTITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'altitude', :optional => true},
          CAMERAMAKE => {:type => ::Thrift::Types::STRING, :name => 'cameraMake', :optional => true},
          CAMERAMODEL => {:type => ::Thrift::Types::STRING, :name => 'cameraModel', :optional => true},
          CLIENTWILLINDEX => {:type => ::Thrift::Types::BOOL, :name => 'clientWillIndex', :optional => true},
          RECOTYPE => {:type => ::Thrift::Types::STRING, :name => 'recoType', :optional => true},
          FILENAME => {:type => ::Thrift::Types::STRING, :name => 'fileName', :optional => true},
          ATTACHMENT => {:type => ::Thrift::Types::BOOL, :name => 'attachment', :optional => true},
          APPLICATIONDATA => {:type => ::Thrift::Types::STRUCT, :name => 'applicationData', :class => ::Evernote::EDAM::Type::LazyMap, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Every media file that is embedded or attached to a note is represented
# through a Resource entry.
# <dl>
# <dt>guid</dt>
#   <dd>The unique identifier of this resource.  Will be set whenever
#   a resource is retrieved from the service, but may be null when a client
#   is creating a resource.
#   <br/>
#   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
#   <br/>
#   Regex:  EDAM_GUID_REGEX
#   </dd>
# 
# <dt>noteGuid</dt>
#   <dd>The unique identifier of the Note that holds this
#   Resource. Will be set whenever the resource is retrieved from the service,
#   but may be null when a client is creating a resource.
#   <br/>
#   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
#   <br/>
#   Regex:  EDAM_GUID_REGEX
#   </dd>
# 
# <dt>data</dt>
#   <dd>The contents of the resource.
#   Maximum length:  The data.body is limited to EDAM_RESOURCE_SIZE_MAX_FREE
#   for free accounts and EDAM_RESOURCE_SIZE_MAX_PREMIUM for premium accounts.
#   </dd>
# 
# <dt>mime</dt>
#   <dd>The MIME type for the embedded resource.  E.g. "image/gif"
#   <br/>
#   Length:  EDAM_MIME_LEN_MIN - EDAM_MIME_LEN_MAX
#   <br/>
#   Regex:  EDAM_MIME_REGEX
#   </dd>
# 
# <dt>width</dt>
#   <dd>If set, this contains the display width of this resource, in
#   pixels.
#   </dd>
# 
# <dt>height</dt>
#   <dd>If set, this contains the display height of this resource,
#   in pixels.
#   </dd>
# 
# <dt>duration</dt>
#   <dd>DEPRECATED: ignored.
#   </dd>
# 
# <dt>active</dt>
#   <dd>DEPRECATED: ignored.
#   </dd>
# 
# <dt>recognition</dt>
#   <dd>If set, this will hold the encoded data that provides
#   information on search and recognition within this resource.
#   </dd>
# 
# <dt>attributes</dt>
#   <dd>A list of the attributes for this resource.
#   </dd>
# 
# <dt>updateSequenceNum</dt>
#   <dd>A number identifying the last transaction to
#   modify the state of this object. The USN values are sequential within an
#   account, and can be used to compare the order of modifications within the
#   service.
#   </dd>
# 
# <dt>alternateData</dt>
#   <dd>Some Resources may be assigned an alternate data format by the service
#   which may be more appropriate for indexing or rendering than the original
#   data provided by the user.  In these cases, the alternate data form will
#   be available via this Data element.  If a Resource has no alternate form,
#   this field will be unset.</dd>
# </dl>
      class Resource
        include ::Thrift::Struct, ::Thrift::Struct_Union
        GUID = 1
        NOTEGUID = 2
        DATA = 3
        MIME = 4
        WIDTH = 5
        HEIGHT = 6
        DURATION = 7
        ACTIVE = 8
        RECOGNITION = 9
        ATTRIBUTES = 11
        UPDATESEQUENCENUM = 12
        ALTERNATEDATA = 13

        FIELDS = {
          GUID => {:type => ::Thrift::Types::STRING, :name => 'guid', :optional => true},
          NOTEGUID => {:type => ::Thrift::Types::STRING, :name => 'noteGuid', :optional => true},
          DATA => {:type => ::Thrift::Types::STRUCT, :name => 'data', :class => ::Evernote::EDAM::Type::Data, :optional => true},
          MIME => {:type => ::Thrift::Types::STRING, :name => 'mime', :optional => true},
          WIDTH => {:type => ::Thrift::Types::I16, :name => 'width', :optional => true},
          HEIGHT => {:type => ::Thrift::Types::I16, :name => 'height', :optional => true},
          DURATION => {:type => ::Thrift::Types::I16, :name => 'duration', :optional => true},
          ACTIVE => {:type => ::Thrift::Types::BOOL, :name => 'active', :optional => true},
          RECOGNITION => {:type => ::Thrift::Types::STRUCT, :name => 'recognition', :class => ::Evernote::EDAM::Type::Data, :optional => true},
          ATTRIBUTES => {:type => ::Thrift::Types::STRUCT, :name => 'attributes', :class => ::Evernote::EDAM::Type::ResourceAttributes, :optional => true},
          UPDATESEQUENCENUM => {:type => ::Thrift::Types::I32, :name => 'updateSequenceNum', :optional => true},
          ALTERNATEDATA => {:type => ::Thrift::Types::STRUCT, :name => 'alternateData', :class => ::Evernote::EDAM::Type::Data, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The list of optional attributes that can be stored on a note.
# <dl>
# <dt>subjectDate</dt>
#   <dd>time that the note refers to
#   </dd>
# 
# <dt>latitude</dt>
#   <dd>the latitude where the note was taken
#   </dd>
# 
# <dt>longitude</dt>
#   <dd>the longitude where the note was taken
#   </dd>
# 
# <dt>altitude</dt>
#   <dd>the altitude where the note was taken
#   </dd>
# 
# <dt>author</dt>
#   <dd>the author of the content of the note
#   <br/>
#   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#   </dd>
# 
# <dt>source</dt>
#   <dd>the method that the note was added to the account, if the
#   note wasn't directly authored in an Evernote desktop client.
#   <br/>
#   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#   </dd>
# 
# <dt>sourceURL</dt>
#   <dd>the original location where the resource was hosted. For web clips,
#   this will be the URL of the page that was clipped.
#   <br/>
#   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#   </dd>
# 
# <dt>sourceApplication</dt>
#   <dd>an identifying string for the application that
#   created this note.  This string does not have a guaranteed syntax or
#   structure -- it is intended for human inspection and tracking.
#   <br/>
#   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#   </dd>
# 
# <dt>shareDate</dt>
#  <dd>The date and time when this note was directly shared via its own URL.
#  This is only set on notes that were individually shared - it is independent
#  of any notebook-level sharing of the containing notebook. This field
#  is treated as "read-only" for clients; the server will ignore changes
#  to this field from an external client.
#  </dd>
# 
# <dt>reminderOrder</dt>
# <dd>The set of notes with this parameter set are considered
# "reminders" and are to be treated specially by clients to give them
# higher UI prominence within a notebook.  The value is used to sort
# the reminder notes within the notebook with higher values
# representing greater prominence.  Outside of the context of a
# notebook, the value of this parameter is undefined.  The value is
# not intended to be compared to the values of reminder notes in
# other notebooks.  In order to allow clients to place a note at a
# higher precedence than other notes, you should never set a value
# greater than the current time (as defined for a Timetstamp). To
# place a note at higher precedence than existing notes, set the
# value to the current time as defined for a timestamp (milliseconds
# since the epoch).  Synchronizing clients must remember the time when
# the update was performed, using the local clock on the client,
# and use that value when they later upload the note to the service.
# Clients must not set the reminderOrder to the reminderTime as the
# reminderTime could be in the future.  Those two fields are never
# intended to be related.  The correct value for reminderOrder field
# for new notes is the "current" time when the user indicated that
# the note is a reminder.  Clients may implement a separate
# "sort by date" feature to show notes ordered by reminderTime.
# Whenever a reminderDoneTime or reminderTime is set but a
# reminderOrder is not set, the server will fill in the current
# server time for the reminderOrder field.</dd>
# 
# <dt>reminderDoneTime</dt>
# <dd>The date and time when a user dismissed/"marked done" the reminder
# on the note.  Users typically do not manually set this value directly
# as it is set to the time when the user dismissed/"marked done" the
# reminder.</dd>
# 
# <dt>reminderTime</dt>
# <dd>The date and time a user has selected to be reminded of the note.
# A note with this value set is known as a "reminder" and the user can
# be reminded, via e-mail or client-specific notifications, of the note
# when the time is reached or about to be reached.  When a user sets
# a reminder time on a note that has a reminder done time, and that
# reminder time is in the future, then the reminder done time should be
# cleared.  This should happen regardless of any existing reminder time
# that may have previously existed on the note.</dd>
# 
# <dt>placeName</dt>
# <dd>Allows the user to assign a human-readable location name associated
# with a note. Users may assign values like 'Home' and 'Work'. Place
# names may also be populated with values from geonames database
# (e.g., a restaurant name). Applications are encouraged to normalize values
# so that grouping values by place name provides a useful result. Applications
# MUST NOT automatically add place name values based on geolocation without
# confirmation from the user; that is, the value in this field should be
# more useful than a simple automated lookup based on the note's latitude
# and longitude.</dd>
# 
# <dt>contentClass</dt>
# <dd>The class (or type) of note. This field is used to indicate to
# clients that special structured information is represented within
# the note such that special rules apply when making
# modifications. If contentClass is set and the client
# application does not specifically support the specified class,
# the client MUST treat the note as read-only. In this case, the
# client MAY modify the note's notebook and tags via the
# Note.notebookGuid and Note.tagGuids fields.  The client MAY also
# modify the reminderOrder field as well as the reminderTime and
# reminderDoneTime fields.
# <p>Applications should set contentClass only when they are creating notes
# that contain structured information that needs to be maintained in order
# for the user to be able to use the note within that application.
# Setting contentClass makes a note read-only in other applications, so
# there is a trade-off when an application chooses to use contentClass.
# Applications that set contentClass when creating notes must use a contentClass
# string of the form <i>CompanyName.ApplicationName</i> to ensure uniqueness.</p>
# Length restrictions: EDAM_NOTE_CONTENT_CLASS_LEN_MIN, EDAM_NOTE_CONTENT_CLASS_LEN_MAX
# <br/>
# Regex: EDAM_NOTE_CONTENT_CLASS_REGEX
# </dd>
# 
# <dt>applicationData</dt>
# <dd>Provides a location for applications to store a relatively small
# (4kb) blob of data that is not meant to be visible to the user and
# that is opaque to the Evernote service. A single application may use at most
# one entry in this map, using its API consumer key as the map key. See the
# documentation for LazyMap for a description of when the actual map values
# are returned by the service.
# <p>To safely add or modify your application's entry in the map, use
# NoteStore.setNoteApplicationDataEntry. To safely remove your application's
# entry from the map, use NoteStore.unsetNoteApplicationDataEntry.</p>
# Minimum length of a name (key): EDAM_APPLICATIONDATA_NAME_LEN_MIN
# <br/>
# Sum max size of key and value: EDAM_APPLICATIONDATA_ENTRY_LEN_MAX
# <br/>
# Syntax regex for name (key): EDAM_APPLICATIONDATA_NAME_REGEX
# </dd>
# 
# <dt>creatorId</dt>
# <dd>The numeric user ID of the user who originally created the note.</dd>
# 
# <dt>lastEditedBy</dt>
# <dd>An indication of who made the last change to the note.  If you are
# accessing the note via a shared notebook to which you have modification
# rights, or if you are the owner of the notebook to which the note belongs,
# then you have access to the value.  In this case, the value will be
# unset if the owner of the notebook containing the note was the last to
# make the modification, else it will be a string describing the
# guest who made the last edit.  If you do not have access to this value,
# it will be left unset.  This field is read-only by clients.  The server
# will ignore all values set by clients into this field.</dd>
# 
# <dt>lastEditorId</dt>
# <dd>The numeric user ID of the user described in lastEditedBy.</dd>
# 
# <dt>classifications</dt>
# <dd>A map of classifications applied to the note by clients or by the
# Evernote service. The key is the string name of the classification type,
# and the value is a constant that begins with CLASSIFICATION_.</dd>
# 
# </dl>
      class NoteAttributes
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUBJECTDATE = 1
        LATITUDE = 10
        LONGITUDE = 11
        ALTITUDE = 12
        AUTHOR = 13
        SOURCE = 14
        SOURCEURL = 15
        SOURCEAPPLICATION = 16
        SHAREDATE = 17
        REMINDERORDER = 18
        REMINDERDONETIME = 19
        REMINDERTIME = 20
        PLACENAME = 21
        CONTENTCLASS = 22
        APPLICATIONDATA = 23
        LASTEDITEDBY = 24
        CLASSIFICATIONS = 26
        CREATORID = 27
        LASTEDITORID = 28

        FIELDS = {
          SUBJECTDATE => {:type => ::Thrift::Types::I64, :name => 'subjectDate', :optional => true},
          LATITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'latitude', :optional => true},
          LONGITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'longitude', :optional => true},
          ALTITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'altitude', :optional => true},
          AUTHOR => {:type => ::Thrift::Types::STRING, :name => 'author', :optional => true},
          SOURCE => {:type => ::Thrift::Types::STRING, :name => 'source', :optional => true},
          SOURCEURL => {:type => ::Thrift::Types::STRING, :name => 'sourceURL', :optional => true},
          SOURCEAPPLICATION => {:type => ::Thrift::Types::STRING, :name => 'sourceApplication', :optional => true},
          SHAREDATE => {:type => ::Thrift::Types::I64, :name => 'shareDate', :optional => true},
          REMINDERORDER => {:type => ::Thrift::Types::I64, :name => 'reminderOrder', :optional => true},
          REMINDERDONETIME => {:type => ::Thrift::Types::I64, :name => 'reminderDoneTime', :optional => true},
          REMINDERTIME => {:type => ::Thrift::Types::I64, :name => 'reminderTime', :optional => true},
          PLACENAME => {:type => ::Thrift::Types::STRING, :name => 'placeName', :optional => true},
          CONTENTCLASS => {:type => ::Thrift::Types::STRING, :name => 'contentClass', :optional => true},
          APPLICATIONDATA => {:type => ::Thrift::Types::STRUCT, :name => 'applicationData', :class => ::Evernote::EDAM::Type::LazyMap, :optional => true},
          LASTEDITEDBY => {:type => ::Thrift::Types::STRING, :name => 'lastEditedBy', :optional => true},
          CLASSIFICATIONS => {:type => ::Thrift::Types::MAP, :name => 'classifications', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}, :optional => true},
          CREATORID => {:type => ::Thrift::Types::I32, :name => 'creatorId', :optional => true},
          LASTEDITORID => {:type => ::Thrift::Types::I32, :name => 'lastEditorId', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Represents a single note in the user's account.
# 
# <dl>
# <dt>guid</dt>
#   <dd>The unique identifier of this note.  Will be set by the
#   server, but will be omitted by clients calling NoteStore.createNote()
#   <br/>
#   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
#   <br/>
#   Regex:  EDAM_GUID_REGEX
#   </dd>
# 
# <dt>title</dt>
#   <dd>The subject of the note.  Can't begin or end with a space.
#   <br/>
#   Length:  EDAM_NOTE_TITLE_LEN_MIN - EDAM_NOTE_TITLE_LEN_MAX
#   <br/>
#   Regex:  EDAM_NOTE_TITLE_REGEX
#   </dd>
# 
# <dt>content</dt>
#   <dd>The XHTML block that makes up the note.  This is
#   the canonical form of the note's contents, so will include abstract
#   Evernote tags for internal resource references.  A client may create
#   a separate transformed version of this content for internal presentation,
#   but the same canonical bytes should be used for transmission and
#   comparison unless the user chooses to modify their content.
#   <br/>
#   Length:  EDAM_NOTE_CONTENT_LEN_MIN - EDAM_NOTE_CONTENT_LEN_MAX
#   </dd>
# 
# <dt>contentHash</dt>
#   <dd>The binary MD5 checksum of the UTF-8 encoded content
#   body. This will always be set by the server, but clients may choose to omit
#   this when they submit a note with content.
#   <br/>
#   Length:  EDAM_HASH_LEN (exactly)
#   </dd>
# 
# <dt>contentLength</dt>
#   <dd>The number of Unicode characters in the content of
#   the note.  This will always be set by the service, but clients may choose
#   to omit this value when they submit a Note.
#   </dd>
# 
# <dt>created</dt>
#   <dd>The date and time when the note was created in one of the
#   clients.  In most cases, this will match the user's sense of when
#   the note was created, and ordering between notes will be based on
#   ordering of this field.  However, this is not a "reliable" timestamp
#   if a client has an incorrect clock, so it cannot provide a true absolute
#   ordering between notes.  Notes created directly through the service
#   (e.g. via the web GUI) will have an absolutely ordered "created" value.
#   </dd>
# 
# <dt>updated</dt>
#   <dd>The date and time when the note was last modified in one of
#   the clients.  In most cases, this will match the user's sense of when
#   the note was modified, but this field may not be absolutely reliable
#   due to the possibility of client clock errors.
#   </dd>
# 
# <dt>deleted</dt>
#   <dd>If present, the note is considered "deleted", and this
#   stores the date and time when the note was deleted by one of the clients.
#   In most cases, this will match the user's sense of when the note was
#   deleted, but this field may be unreliable due to the possibility of
#   client clock errors.
#   </dd>
# 
# <dt>active</dt>
#   <dd>If the note is available for normal actions and viewing,
#   this flag will be set to true.
#   </dd>
# 
# <dt>updateSequenceNum</dt>
#   <dd>A number identifying the last transaction to
#   modify the state of this note (including changes to the note's attributes
#   or resources).  The USN values are sequential within an account,
#   and can be used to compare the order of modifications within the service.
#   </dd>
# 
# <dt>notebookGuid</dt>
#   <dd>The unique identifier of the notebook that contains
#   this note.  If no notebookGuid is provided on a call to createNote(), the
#   default notebook will be used instead.
#   <br/>
#   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
#   <br/>
#   Regex:  EDAM_GUID_REGEX
#   </dd>
# 
# <dt>tagGuids</dt>
#   <dd>A list of the GUID identifiers for tags that are applied to this note.
#   This may be provided in a call to createNote() to unambiguously declare
#   the tags that should be assigned to the new note.  Alternately, clients
#   may pass the names of desired tags via the 'tagNames' field during
#   note creation.
#   If the list of tags are omitted on a call to createNote(), then
#   the server will assume that no changes have been made to the resources.
#   Maximum:  EDAM_NOTE_TAGS_MAX tags per note
#   </dd>
# 
# <dt>resources</dt>
#   <dd>The list of resources that are embedded within this note.
#   If the list of resources are omitted on a call to updateNote(), then
#   the server will assume that no changes have been made to the resources.
#   The binary contents of the resources must be provided when the resource
#   is first sent to the service, but it will be omitted by the service when
#   the Note is returned in the future.
#   Maximum:  EDAM_NOTE_RESOURCES_MAX resources per note
#   </dd>
# 
# <dt>attributes</dt>
#   <dd>A list of the attributes for this note.
#   If the list of attributes are omitted on a call to updateNote(), then
#   the server will assume that no changes have been made to the resources.
#   </dd>
# 
# <dt>tagNames</dt>
#   <dd>May be provided by clients during calls to createNote() as an
#   alternative to providing the tagGuids of existing tags.  If any tagNames
#   are provided during createNote(), these will be found, or created if they
#   don't already exist.  Created tags will have no parent (they will be at
#   the top level of the tag panel).
#   </dd>
# </dl>
      class Note
        include ::Thrift::Struct, ::Thrift::Struct_Union
        GUID = 1
        TITLE = 2
        CONTENT = 3
        CONTENTHASH = 4
        CONTENTLENGTH = 5
        CREATED = 6
        UPDATED = 7
        DELETED = 8
        ACTIVE = 9
        UPDATESEQUENCENUM = 10
        NOTEBOOKGUID = 11
        TAGGUIDS = 12
        RESOURCES = 13
        ATTRIBUTES = 14
        TAGNAMES = 15

        FIELDS = {
          GUID => {:type => ::Thrift::Types::STRING, :name => 'guid', :optional => true},
          TITLE => {:type => ::Thrift::Types::STRING, :name => 'title', :optional => true},
          CONTENT => {:type => ::Thrift::Types::STRING, :name => 'content', :optional => true},
          CONTENTHASH => {:type => ::Thrift::Types::STRING, :name => 'contentHash', :binary => true, :optional => true},
          CONTENTLENGTH => {:type => ::Thrift::Types::I32, :name => 'contentLength', :optional => true},
          CREATED => {:type => ::Thrift::Types::I64, :name => 'created', :optional => true},
          UPDATED => {:type => ::Thrift::Types::I64, :name => 'updated', :optional => true},
          DELETED => {:type => ::Thrift::Types::I64, :name => 'deleted', :optional => true},
          ACTIVE => {:type => ::Thrift::Types::BOOL, :name => 'active', :optional => true},
          UPDATESEQUENCENUM => {:type => ::Thrift::Types::I32, :name => 'updateSequenceNum', :optional => true},
          NOTEBOOKGUID => {:type => ::Thrift::Types::STRING, :name => 'notebookGuid', :optional => true},
          TAGGUIDS => {:type => ::Thrift::Types::LIST, :name => 'tagGuids', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          RESOURCES => {:type => ::Thrift::Types::LIST, :name => 'resources', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Evernote::EDAM::Type::Resource}, :optional => true},
          ATTRIBUTES => {:type => ::Thrift::Types::STRUCT, :name => 'attributes', :class => ::Evernote::EDAM::Type::NoteAttributes, :optional => true},
          TAGNAMES => {:type => ::Thrift::Types::LIST, :name => 'tagNames', :element => {:type => ::Thrift::Types::STRING}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # If a Notebook has been opened to the public, the Notebook will have a
# reference to one of these structures, which gives the location and optional
# description of the externally-visible public Notebook.
# <dl>
# <dt>uri</dt>
#   <dd>If this field is present, then the notebook is published for
#   mass consumption on the Internet under the provided URI, which is
#   relative to a defined base publishing URI defined by the service.
#   This field can only be modified via the web service GUI ... publishing
#   cannot be modified via an offline client.
#   <br/>
#   Length:  EDAM_PUBLISHING_URI_LEN_MIN - EDAM_PUBLISHING_URI_LEN_MAX
#   <br/>
#   Regex:  EDAM_PUBLISHING_URI_REGEX
#   </dd>
# 
# <dt>order</dt>
#   <dd>When the notes are publicly displayed, they will be sorted
#   based on the requested criteria.
#   </dd>
# 
# <dt>ascending</dt>
#   <dd>If this is set to true, then the public notes will be
#   displayed in ascending order (e.g. from oldest to newest).  Otherwise,
#   the notes will be displayed in descending order (e.g. newest to oldest).
#   </dd>
# 
# <dt>publicDescription</dt>
#   <dd>This field may be used to provide a short
#   description of the notebook, which may be displayed when (e.g.) the
#   notebook is shown in a public view.  Can't begin or end with a space.
#   <br/>
#   Length:  EDAM_PUBLISHING_DESCRIPTION_LEN_MIN -
#            EDAM_PUBLISHING_DESCRIPTION_LEN_MAX
#   <br/>
#   Regex:  EDAM_PUBLISHING_DESCRIPTION_REGEX
#   </dd>
# 
# </dl>
      class Publishing
        include ::Thrift::Struct, ::Thrift::Struct_Union
        URI = 1
        ORDER = 2
        ASCENDING = 3
        PUBLICDESCRIPTION = 4

        FIELDS = {
          URI => {:type => ::Thrift::Types::STRING, :name => 'uri', :optional => true},
          ORDER => {:type => ::Thrift::Types::I32, :name => 'order', :optional => true, :enum_class => ::Evernote::EDAM::Type::NoteSortOrder},
          ASCENDING => {:type => ::Thrift::Types::BOOL, :name => 'ascending', :optional => true},
          PUBLICDESCRIPTION => {:type => ::Thrift::Types::STRING, :name => 'publicDescription', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @order.nil? || ::Evernote::EDAM::Type::NoteSortOrder::VALID_VALUES.include?(@order)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field order!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # If a Notebook contained in an Evernote Business account has been published
# the to business library, the Notebook will have a reference to one of these
# structures, which specifies how the Notebook will be represented in the
# library.
# 
# <dl>
# <dt>notebookDescription</dt>
#   <dd>A short description of the notebook's content that will be displayed
#       in the business library user interface. The description may not begin
#       or end with whitespace.
#   <br/>
#   Length: EDAM_BUSINESS_NOTEBOOK_DESCRIPTION_LEN_MIN -
#           EDAM_BUSINESS_NOTEBOOK_DESCRIPTION_LEN_MAX
#   <br/>
#   Regex:  EDAM_BUSINESS_NOTEBOOK_DESCRIPTION_REGEX
#   </dd>
# 
# <dt>privilege</dt>
#   <dd>The privileges that will be granted to users who join the notebook through
#       the business library.
#   </dd>
# 
# <dt>recommended</dt>
#   <dd>Whether the notebook should be "recommended" when displayed in the business
#       library user interface.
#   </dd>
# </dl>
      class BusinessNotebook
        include ::Thrift::Struct, ::Thrift::Struct_Union
        NOTEBOOKDESCRIPTION = 1
        PRIVILEGE = 2
        RECOMMENDED = 3

        FIELDS = {
          NOTEBOOKDESCRIPTION => {:type => ::Thrift::Types::STRING, :name => 'notebookDescription', :optional => true},
          PRIVILEGE => {:type => ::Thrift::Types::I32, :name => 'privilege', :optional => true, :enum_class => ::Evernote::EDAM::Type::SharedNotebookPrivilegeLevel},
          RECOMMENDED => {:type => ::Thrift::Types::BOOL, :name => 'recommended', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @privilege.nil? || ::Evernote::EDAM::Type::SharedNotebookPrivilegeLevel::VALID_VALUES.include?(@privilege)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field privilege!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A structure defining the scope of a SavedSearch.
# 
# <dl>
#   <dt>includeAccount</dt>
#   <dd>The search should include notes from the account that contains the SavedSearch.</dd>
# 
#   <dt>includePersonalLinkedNotebooks</dt>
#   <dd>The search should include notes within those shared notebooks
#   that the user has joined that are NOT business notebooks.</dd>
# 
#   <dt>includeBusinessLinkedNotebooks</dt>
#   <dd>The search should include notes within those shared notebooks
#   that the user has joined that are business notebooks in the business that
#   the user is currently a member of.</dd>
# </dl>
      class SavedSearchScope
        include ::Thrift::Struct, ::Thrift::Struct_Union
        INCLUDEACCOUNT = 1
        INCLUDEPERSONALLINKEDNOTEBOOKS = 2
        INCLUDEBUSINESSLINKEDNOTEBOOKS = 3

        FIELDS = {
          INCLUDEACCOUNT => {:type => ::Thrift::Types::BOOL, :name => 'includeAccount', :optional => true},
          INCLUDEPERSONALLINKEDNOTEBOOKS => {:type => ::Thrift::Types::BOOL, :name => 'includePersonalLinkedNotebooks', :optional => true},
          INCLUDEBUSINESSLINKEDNOTEBOOKS => {:type => ::Thrift::Types::BOOL, :name => 'includeBusinessLinkedNotebooks', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A named search associated with the account that can be quickly re-used.
# <dl>
# <dt>guid</dt>
#   <dd>The unique identifier of this search.  Will be set by the
#   service, so may be omitted by the client when creating.
#   <br/>
#   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
#   <br/>
#   Regex:  EDAM_GUID_REGEX
#   </dd>
# 
# <dt>name</dt>
#   <dd>The name of the saved search to display in the GUI.  The
#   account may only contain one search with a given name (case-insensitive
#   compare). Can't begin or end with a space.
#   <br/>
#   Length:  EDAM_SAVED_SEARCH_NAME_LEN_MIN - EDAM_SAVED_SEARCH_NAME_LEN_MAX
#   <br/>
#   Regex:  EDAM_SAVED_SEARCH_NAME_REGEX
#   </dd>
# 
# <dt>query</dt>
#   <dd>A string expressing the search to be performed.
#   <br/>
#   Length:  EDAM_SAVED_SEARCH_QUERY_LEN_MIN - EDAM_SAVED_SEARCH_QUERY_LEN_MAX
#   </dd>
# 
# <dt>format</dt>
#   <dd>The format of the query string, to determine how to parse
#   and process it.
#   </dd>
# 
# <dt>updateSequenceNum</dt>
#   <dd>A number identifying the last transaction to
#   modify the state of this object.  The USN values are sequential within an
#   account, and can be used to compare the order of modifications within the
#   service.
#   </dd>
# 
# <dt>scope</dt>
#   <dd><p>Specifies the set of notes that should be included in the search, if
#    possible.</p>
#    <p>Clients are expected to search as much of the desired scope as possible,
#    with the understanding that a given client may not be able to cover the full
#    specified scope. For example, when executing a search that includes notes in both
#    the owner's account and business notebooks, a mobile client may choose to only
#    search within the user's account because it is not capable of searching both
#    scopes simultaneously. When a search across multiple scopes is not possible,
#    a client may choose which scope to search based on the current application
#    context. If a client cannot search any of the desired scopes, it should refuse
#    to execute the search.</p>
#    </dd>
# </dl>
      class SavedSearch
        include ::Thrift::Struct, ::Thrift::Struct_Union
        GUID = 1
        NAME = 2
        QUERY = 3
        FORMAT = 4
        UPDATESEQUENCENUM = 5
        SCOPE = 6

        FIELDS = {
          GUID => {:type => ::Thrift::Types::STRING, :name => 'guid', :optional => true},
          NAME => {:type => ::Thrift::Types::STRING, :name => 'name', :optional => true},
          QUERY => {:type => ::Thrift::Types::STRING, :name => 'query', :optional => true},
          FORMAT => {:type => ::Thrift::Types::I32, :name => 'format', :optional => true, :enum_class => ::Evernote::EDAM::Type::QueryFormat},
          UPDATESEQUENCENUM => {:type => ::Thrift::Types::I32, :name => 'updateSequenceNum', :optional => true},
          SCOPE => {:type => ::Thrift::Types::STRUCT, :name => 'scope', :class => ::Evernote::EDAM::Type::SavedSearchScope, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @format.nil? || ::Evernote::EDAM::Type::QueryFormat::VALID_VALUES.include?(@format)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field format!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Settings meant for the recipient of a shared notebook, such as
# for indicating which types of notifications the recipient wishes
# for reminders, etc.
# 
# The reminderNotifyEmail and reminderNotifyInApp fields have a
# 3-state read value but a 2-state write value.  On read, it is
# possible to observe "unset", true, or false.  The initial state is
# "unset".  When you choose to set a value, you may set it to either
# true or false, but you cannot unset the value.  Once one of these
# members has a true/false value, it will always have a true/false
# value.
# 
# <dl>
# <dt>reminderNotifyEmail</dt>
# <dd>Indicates that the user wishes to receive daily e-mail notifications
#     for reminders associated with the shared notebook.  This may be
#     true only for business notebooks that belong to the business of
#     which the user is a member.  You may only set this value on a
#     notebook in your business.</dd>
# <dt>reminderNotifyInApp</dt>
# <dd>Indicates that the user wishes to receive notifications for
#     reminders by applications that support providing such
#     notifications.  The exact nature of the notification is defined
#     by the individual applications.</dd>
# </dl>
# 
      class SharedNotebookRecipientSettings
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REMINDERNOTIFYEMAIL = 1
        REMINDERNOTIFYINAPP = 2

        FIELDS = {
          REMINDERNOTIFYEMAIL => {:type => ::Thrift::Types::BOOL, :name => 'reminderNotifyEmail', :optional => true},
          REMINDERNOTIFYINAPP => {:type => ::Thrift::Types::BOOL, :name => 'reminderNotifyInApp', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Shared notebooks represent a relationship between a notebook and a single
# share invitation recipient.
# <dl>
# <dt>id</dt>
# <dd>the primary identifier of the share</dd>
# 
# <dt>userId</dt>
# <dd>the user id of the owner of the notebook</dd>
# 
# <dt>notebookGuid</dt>
# <dd>the GUID of the associated notebook shared.</dd>
# 
# <dt>email</dt>
# <dd>the email address of the recipient - used by the notebook
# owner to identify who they shared with.</dd>
# 
# <dt>notebookModifiable</dt>
# <dd>(DEPRECATED) a flag indicating the share is read/write -otherwise it's read
#     only.  This field is deprecated in favor of the new "privilege" field.</dd>
# 
# <dt>requireLogin</dt>
# <dd>(DEPRECATED) indicates that a user must login to access the share.  This
#     field is deprecated and will be "true" for all new shared notebooks.  It
#     is read-only and ignored when creating or modifying a shared notebook,
#     except that a shared notebook can be modified to require login.
#     See "allowPreview" for information on privileges and shared notebooks.</dd>
# 
# <dt>serviceCreated</dt>
# <dd>the date the owner first created the share with the specific email
#   address</dd>
# 
# <dt>serviceUpdated</dt>
# <dd>the date the shared notebook was last updated on the service.  This
#     will be updated when authenticateToSharedNotebook is called the first
#     time with a shared notebook requiring login (i.e. when the username is
#     bound to that shared notebook).</dd>
# 
# <dt>username</dt>
# <dd>the username of the user who can access this share.
#   Once it's assigned it cannot be changed.</dd>
# 
# <dt>privilege</dt>
# <dd>The privilege level granted to the notebook, activity stream, and
#     invitations.  See the corresponding enumeration for details.</dd>
# 
# <dt>allowPreview</dt>
# <dd>Whether or not to grant "READ_NOTEBOOK" privilege without an
#     authentication token, for authenticateToSharedNotebook(...).  With
#     the change to "requireLogin" always being true for new shared
#     notebooks, this is the only way to access a shared notebook without
#     an authorization token.  This setting expires after the first use
#     of authenticateToSharedNotebook(...) with a valid authentication
#     token.</dd>
# 
# <dt>recipientSettings</dt>
# <dd>Settings intended for use only by the recipient of this shared
#     notebook.  You should skip setting this value unless you want
#     to change the value contained inside the structure, and only if
#     you are the recipient.</dd>
# </dl>
      class SharedNotebook
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ID = 1
        USERID = 2
        NOTEBOOKGUID = 3
        EMAIL = 4
        NOTEBOOKMODIFIABLE = 5
        REQUIRELOGIN = 6
        SERVICECREATED = 7
        SERVICEUPDATED = 10
        SHAREKEY = 8
        USERNAME = 9
        PRIVILEGE = 11
        ALLOWPREVIEW = 12
        RECIPIENTSETTINGS = 13

        FIELDS = {
          ID => {:type => ::Thrift::Types::I64, :name => 'id', :optional => true},
          USERID => {:type => ::Thrift::Types::I32, :name => 'userId', :optional => true},
          NOTEBOOKGUID => {:type => ::Thrift::Types::STRING, :name => 'notebookGuid', :optional => true},
          EMAIL => {:type => ::Thrift::Types::STRING, :name => 'email', :optional => true},
          NOTEBOOKMODIFIABLE => {:type => ::Thrift::Types::BOOL, :name => 'notebookModifiable', :optional => true},
          REQUIRELOGIN => {:type => ::Thrift::Types::BOOL, :name => 'requireLogin', :optional => true},
          SERVICECREATED => {:type => ::Thrift::Types::I64, :name => 'serviceCreated', :optional => true},
          SERVICEUPDATED => {:type => ::Thrift::Types::I64, :name => 'serviceUpdated', :optional => true},
          SHAREKEY => {:type => ::Thrift::Types::STRING, :name => 'shareKey', :optional => true},
          USERNAME => {:type => ::Thrift::Types::STRING, :name => 'username', :optional => true},
          PRIVILEGE => {:type => ::Thrift::Types::I32, :name => 'privilege', :optional => true, :enum_class => ::Evernote::EDAM::Type::SharedNotebookPrivilegeLevel},
          ALLOWPREVIEW => {:type => ::Thrift::Types::BOOL, :name => 'allowPreview', :optional => true},
          RECIPIENTSETTINGS => {:type => ::Thrift::Types::STRUCT, :name => 'recipientSettings', :class => ::Evernote::EDAM::Type::SharedNotebookRecipientSettings, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @privilege.nil? || ::Evernote::EDAM::Type::SharedNotebookPrivilegeLevel::VALID_VALUES.include?(@privilege)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field privilege!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # This structure captures information about the types of operations
# that cannot be performed on a given notebook with a type of
# authenticated access and credentials.  The values filled into this
# structure are based on then-current values in the server database
# for shared notebooks and notebook publishing records, as well as
# information related to the authentication token.  Information from
# the authentication token includes the application that is accessing
# the server, as defined by the permissions granted by consumer (api)
# key, and the method used to obtain the token, for example via
# authenticateToSharedNotebook, authenticateToBusiness, etc.  Note
# that changes to values in this structure that are the result of
# shared notebook or publishing record changes are communicated to
# the client via a change in the notebook USN during sync.  It is
# important to use the same access method, parameters, and consumer
# key in order obtain correct results from the sync engine.
# 
# The server has the final say on what is allowed as values may
# change between calls to obtain NotebookRestrictions instances
# and to operate on data on the service.
# 
# If the following are set and true, then the given restriction is
# in effect, as accessed by the same authentication token from which
# the values were obtained.
# 
# <dt>noReadNotes</dt>
#   <dd>The client is not able to read notes from the service and
#   the notebook is write-only.
#   </dd>
# <dt>noCreateNotes</dt>
#   <dd>The client may not create new notes in the notebook.
#   </dd>
# <dt>noUpdateNotes</dt>
#   <dd>The client may not update notes currently in the notebook.
#   </dd>
# <dt>noExpungeNotes</dt>
#   <dd>The client may not expunge notes currently in the notebook.
#   </dd>
# <dt>noShareNotes</dt>
#   <dd>The client may not share notes in the notebook via the
#   shareNote method.
#   </dd>
# <dt>noEmailNotes</dt>
#   <dd>The client may not e-mail notes via the Evernote service by
#   using the emailNote method.
#   </dd>
# <dt>noSendMessageToRecipients</dt>
#   <dd>The client may not send messages to the share recipients of
#   the notebook.
#   </dd>
# <dt>noUpdateNotebook</dt>
#   <dd>The client may not update the Notebook object itself, for
#   example, via the updateNotebook method.
#   </dd>
# <dt>noExpungeNotebook</dt>
#   <dd>The client may not expunge the Notebook object itself, for
#   example, via the expungeNotebook method.
#   </dd>
# <dt>noSetDefaultNotebook</dt>
#   <dd>The client may not set this notebook to be the default notebook.
#   The caller should leave Notebook.defaultNotebook unset.
#   </dd>
# <dt>noSetNotebookStack</dt>
#   <dd>If the client is able to update the Notebook, the Notebook.stack
#   value may not be set.
#   </dd>
# <dt>noPublishToPublic</dt>
#   <dd>The client may not change the publish the notebook to the public.
#   For example, business notebooks may not be shared publicly.
#   </dd>
# <dt>noPublishToBusinessLibrary</dt>
#   <dd>The client may not publish the notebook to the business library.
#   </dd>
# <dt>noCreateTags</dt>
#   <dd>The client may not complete an operation that results in a new tag
#   being created in the owner's account.
#   </dd>
# <dt>noUpdateTags</dt>
#   <dd>The client may not update tags in the owner's account.
#   </dd>
# <dt>noExpungeTags</dt>
#   <dd>The client may not expunge tags in the owner's account.
#   </dd>
# <dt>noSetParentTag</dt>
#   <dd>If the client is able to create or update tags in the owner's account,
#   then they will not be able to set the parent tag.  Leave the value unset.
#   </dd>
# <dt>noCreateSharedNotebooks</dt>
#   <dd>The client is unable to create shared notebooks for the notebook.
#   </dd>
# <dt>updateWhichSharedNotebookRestrictions</dt>
#   <dd>Restrictions on which shared notebook instances can be updated.  If the
#   value is not set or null, then the client can update any of the shared notebooks
#   associated with the notebook on which the NotebookRestrictions are defined.
#   See the enumeration for further details.
#   </dd>
# <dt>expungeWhichSharedNotebookRestrictions</dt>
#   <dd>Restrictions on which shared notebook instances can be expunged.  If the
#   value is not set or null, then the client can expunge any of the shared notebooks
#   associated with the notebook on which the NotebookRestrictions are defined.
#   See the enumeration for further details.
#   </dd>
      class NotebookRestrictions
        include ::Thrift::Struct, ::Thrift::Struct_Union
        NOREADNOTES = 1
        NOCREATENOTES = 2
        NOUPDATENOTES = 3
        NOEXPUNGENOTES = 4
        NOSHARENOTES = 5
        NOEMAILNOTES = 6
        NOSENDMESSAGETORECIPIENTS = 7
        NOUPDATENOTEBOOK = 8
        NOEXPUNGENOTEBOOK = 9
        NOSETDEFAULTNOTEBOOK = 10
        NOSETNOTEBOOKSTACK = 11
        NOPUBLISHTOPUBLIC = 12
        NOPUBLISHTOBUSINESSLIBRARY = 13
        NOCREATETAGS = 14
        NOUPDATETAGS = 15
        NOEXPUNGETAGS = 16
        NOSETPARENTTAG = 17
        NOCREATESHAREDNOTEBOOKS = 18
        UPDATEWHICHSHAREDNOTEBOOKRESTRICTIONS = 19
        EXPUNGEWHICHSHAREDNOTEBOOKRESTRICTIONS = 20

        FIELDS = {
          NOREADNOTES => {:type => ::Thrift::Types::BOOL, :name => 'noReadNotes', :optional => true},
          NOCREATENOTES => {:type => ::Thrift::Types::BOOL, :name => 'noCreateNotes', :optional => true},
          NOUPDATENOTES => {:type => ::Thrift::Types::BOOL, :name => 'noUpdateNotes', :optional => true},
          NOEXPUNGENOTES => {:type => ::Thrift::Types::BOOL, :name => 'noExpungeNotes', :optional => true},
          NOSHARENOTES => {:type => ::Thrift::Types::BOOL, :name => 'noShareNotes', :optional => true},
          NOEMAILNOTES => {:type => ::Thrift::Types::BOOL, :name => 'noEmailNotes', :optional => true},
          NOSENDMESSAGETORECIPIENTS => {:type => ::Thrift::Types::BOOL, :name => 'noSendMessageToRecipients', :optional => true},
          NOUPDATENOTEBOOK => {:type => ::Thrift::Types::BOOL, :name => 'noUpdateNotebook', :optional => true},
          NOEXPUNGENOTEBOOK => {:type => ::Thrift::Types::BOOL, :name => 'noExpungeNotebook', :optional => true},
          NOSETDEFAULTNOTEBOOK => {:type => ::Thrift::Types::BOOL, :name => 'noSetDefaultNotebook', :optional => true},
          NOSETNOTEBOOKSTACK => {:type => ::Thrift::Types::BOOL, :name => 'noSetNotebookStack', :optional => true},
          NOPUBLISHTOPUBLIC => {:type => ::Thrift::Types::BOOL, :name => 'noPublishToPublic', :optional => true},
          NOPUBLISHTOBUSINESSLIBRARY => {:type => ::Thrift::Types::BOOL, :name => 'noPublishToBusinessLibrary', :optional => true},
          NOCREATETAGS => {:type => ::Thrift::Types::BOOL, :name => 'noCreateTags', :optional => true},
          NOUPDATETAGS => {:type => ::Thrift::Types::BOOL, :name => 'noUpdateTags', :optional => true},
          NOEXPUNGETAGS => {:type => ::Thrift::Types::BOOL, :name => 'noExpungeTags', :optional => true},
          NOSETPARENTTAG => {:type => ::Thrift::Types::BOOL, :name => 'noSetParentTag', :optional => true},
          NOCREATESHAREDNOTEBOOKS => {:type => ::Thrift::Types::BOOL, :name => 'noCreateSharedNotebooks', :optional => true},
          UPDATEWHICHSHAREDNOTEBOOKRESTRICTIONS => {:type => ::Thrift::Types::I32, :name => 'updateWhichSharedNotebookRestrictions', :optional => true, :enum_class => ::Evernote::EDAM::Type::SharedNotebookInstanceRestrictions},
          EXPUNGEWHICHSHAREDNOTEBOOKRESTRICTIONS => {:type => ::Thrift::Types::I32, :name => 'expungeWhichSharedNotebookRestrictions', :optional => true, :enum_class => ::Evernote::EDAM::Type::SharedNotebookInstanceRestrictions}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @updateWhichSharedNotebookRestrictions.nil? || ::Evernote::EDAM::Type::SharedNotebookInstanceRestrictions::VALID_VALUES.include?(@updateWhichSharedNotebookRestrictions)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field updateWhichSharedNotebookRestrictions!')
          end
          unless @expungeWhichSharedNotebookRestrictions.nil? || ::Evernote::EDAM::Type::SharedNotebookInstanceRestrictions::VALID_VALUES.include?(@expungeWhichSharedNotebookRestrictions)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field expungeWhichSharedNotebookRestrictions!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A unique container for a set of notes.
# <dl>
# <dt>guid</dt>
#   <dd>The unique identifier of this notebook.
#   <br/>
#   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
#   <br/>
#   Regex:  EDAM_GUID_REGEX
#   </dd>
# 
# <dt>name</dt>
#   <dd>A sequence of characters representing the name of the
#   notebook.  May be changed by clients, but the account may not contain two
#   notebooks with names that are equal via a case-insensitive comparison.
#   Can't begin or end with a space.
#   <br/>
#   Length:  EDAM_NOTEBOOK_NAME_LEN_MIN - EDAM_NOTEBOOK_NAME_LEN_MAX
#   <br/>
#   Regex:  EDAM_NOTEBOOK_NAME_REGEX
#   </dd>
# 
# <dt>updateSequenceNum</dt>
#   <dd>A number identifying the last transaction to
#   modify the state of this object.  The USN values are sequential within an
#   account, and can be used to compare the order of modifications within the
#   service.
#   </dd>
# 
# <dt>defaultNotebook</dt>
#   <dd>If true, this notebook should be used for new notes
#   whenever the user has not (or cannot) specify a desired target notebook.
#   For example, if a note is submitted via SMTP email.
#   The service will maintain at most one defaultNotebook per account.
#   If a second notebook is created or updated with defaultNotebook set to
#   true, the service will automatically update the prior notebook's
#   defaultNotebook field to false.  If the default notebook is deleted
#   (i.e. "active" set to false), the "defaultNotebook" field will be
#   set to false by the service.  If the account has no default notebook
#   set, the service will use the most recent notebook as the default.
#   </dd>
# 
# <dt>serviceCreated</dt>
#   <dd>The time when this notebook was created on the
#   service. This will be set on the service during creation, and the service
#   will provide this value when it returns a Notebook to a client.
#   The service will ignore this value if it is sent by clients.
#   </dd>
# 
# <dt>serviceUpdated</dt>
#   <dd>The time when this notebook was last modified on the
#   service.  This will be set on the service during creation, and the service
#   will provide this value when it returns a Notebook to a client.
#   The service will ignore this value if it is sent by clients.
#   </dd>
# 
# <dt>publishing</dt>
#   <dd>If the Notebook has been opened for public access, or
#   business users shared with their business (i.e. if 'published' is
#   set to true), then this will point to the set of publishing
#   information for the Notebook (URI, description, etc.).  A
#   Notebook cannot be published without providing this information,
#   but it will persist for later use if publishing is ever disabled
#   on the Notebook.  Clients that do not wish to change the
#   publishing behavior of a Notebook should not set this value when
#   calling NoteStore.updateNotebook().
#   </dd>
# 
# <dt>published</dt>
#   <dd>If this is set to true, then the Notebook will be
#   accessible either to the public, or for business users to their business,
#   via the 'publishing' specification, which must also be set.  If this is set
#   to false, the Notebook will not be available to the public (or business).
#   Clients that do not wish to change the publishing behavior of a Notebook
#   should not set this value when calling NoteStore.updateNotebook().
#   </dd>
# 
# <dt>stack</dt>
#   <dd>If this is set, then the notebook is visually contained within a stack
#   of notebooks with this name.  All notebooks in the same account with the
#   same 'stack' field are considered to be in the same stack.
#   Notebooks with no stack set are "top level" and not contained within a
#   stack.
#   </dd>
# 
# <dt>sharedNotebookIds</dt>
#   <dd><i>DEPRECATED</i> - replaced by sharedNotebooks.</dd>
# 
# <dt>sharedNotebooks</dt>
#   <dd>The list of recipients to whom this notebook has been shared
#   (one SharedNotebook object per recipient email address). This field will
#   be unset if you do not have permission to access this data. If you are
#   accessing the notebook as the owner or via a shared notebook that is
#   modifiable, then you have access to this data and the value will be set.
#   This field is read-only. Clients may not make changes to shared notebooks
#   via this field.
#   </dd>
# 
# <dt>businessNotebook</dt>
#   <dd>If the notebook is part of a business account and has been published to the
#   business library, this will contain information for the library listing.
#   The presence or absence of this field is not a reliable test of whether a given
#   notebook is in fact a business notebook - the field is only used when a notebook is or
#   has been published to the business library.
#   </dd>
# 
# <dt>contact</dt>
#   <dd>Intended for use with Business accounts, this field identifies the user who
#   has been designated as the "contact".  For notebooks created in business
#   accounts, the server will automatically set this value to the user who created
#   the notebook unless Notebook.contact.username has been set, in which that value
#   will be used.  When updating a notebook, it is common to leave Notebook.contact
#   field unset, indicating that no change to the value is being requested and that
#   the existing value, if any, should be preserved.
#   </dd>
# 
# </dl>
      class Notebook
        include ::Thrift::Struct, ::Thrift::Struct_Union
        GUID = 1
        NAME = 2
        UPDATESEQUENCENUM = 5
        DEFAULTNOTEBOOK = 6
        SERVICECREATED = 7
        SERVICEUPDATED = 8
        PUBLISHING = 10
        PUBLISHED = 11
        STACK = 12
        SHAREDNOTEBOOKIDS = 13
        SHAREDNOTEBOOKS = 14
        BUSINESSNOTEBOOK = 15
        CONTACT = 16
        RESTRICTIONS = 17

        FIELDS = {
          GUID => {:type => ::Thrift::Types::STRING, :name => 'guid', :optional => true},
          NAME => {:type => ::Thrift::Types::STRING, :name => 'name', :optional => true},
          UPDATESEQUENCENUM => {:type => ::Thrift::Types::I32, :name => 'updateSequenceNum', :optional => true},
          DEFAULTNOTEBOOK => {:type => ::Thrift::Types::BOOL, :name => 'defaultNotebook', :optional => true},
          SERVICECREATED => {:type => ::Thrift::Types::I64, :name => 'serviceCreated', :optional => true},
          SERVICEUPDATED => {:type => ::Thrift::Types::I64, :name => 'serviceUpdated', :optional => true},
          PUBLISHING => {:type => ::Thrift::Types::STRUCT, :name => 'publishing', :class => ::Evernote::EDAM::Type::Publishing, :optional => true},
          PUBLISHED => {:type => ::Thrift::Types::BOOL, :name => 'published', :optional => true},
          STACK => {:type => ::Thrift::Types::STRING, :name => 'stack', :optional => true},
          SHAREDNOTEBOOKIDS => {:type => ::Thrift::Types::LIST, :name => 'sharedNotebookIds', :element => {:type => ::Thrift::Types::I64}, :optional => true},
          SHAREDNOTEBOOKS => {:type => ::Thrift::Types::LIST, :name => 'sharedNotebooks', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Evernote::EDAM::Type::SharedNotebook}, :optional => true},
          BUSINESSNOTEBOOK => {:type => ::Thrift::Types::STRUCT, :name => 'businessNotebook', :class => ::Evernote::EDAM::Type::BusinessNotebook, :optional => true},
          CONTACT => {:type => ::Thrift::Types::STRUCT, :name => 'contact', :class => ::Evernote::EDAM::Type::User, :optional => true},
          RESTRICTIONS => {:type => ::Thrift::Types::STRUCT, :name => 'restrictions', :class => ::Evernote::EDAM::Type::NotebookRestrictions, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A link in an users account that refers them to a public or individual share in
# another user's account.
# 
# <dl>
# <dt>shareName</dt>
# <dd>the display name of the shared notebook.
#   The link owner can change this.</dd>
# 
# <dt>username</dt>
# <dd>the username of the user who owns the shared or public notebook</dd>
# 
# <dt>shardId</dt>
# <dd>the shard ID of the notebook if the notebook is not public</dt>
# 
# <dt>shareKey</dt>
# <dd>the secret key that provides access to the shared notebook</dd>
# 
# <dt>uri</dt>
# <dd>the identifier of the public notebook</dd>
# 
# <dt>guid</dt>
#   <dd>The unique identifier of this linked notebook.  Will be set whenever
#   a linked notebook is retrieved from the service, but may be null when a client
#   is creating a linked notebook.
#   <br/>
#   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
#   <br/>
#   Regex:  EDAM_GUID_REGEX
#   </dd>
# 
# <dt>updateSequenceNum</dt>
#   <dd>A number identifying the last transaction to
#   modify the state of this object.  The USN values are sequential within an
#   account, and can be used to compare the order of modifications within the
#   service.
#   </dd>
# 
# <dt>noteStoreUrl</dt>
#   <dd>
#   This field will contain the full URL that clients should use to make
#   NoteStore requests to the server shard that contains that notebook's data.
#   I.e. this is the URL that should be used to create the Thrift HTTP client
#   transport to send messages to the NoteStore service for the account.
#   </dd>
# 
# <dt>webApiUrlPrefix:</dt>
#   <dd>
#   This field will contain the initial part of the URLs that should be used
#   to make requests to Evernote's thin client "web API", which provide
#   optimized operations for clients that aren't capable of manipulating
#   the full contents of accounts via the full Thrift data model. Clients
#   should concatenate the relative path for the various servlets onto the
#   end of this string to construct the full URL, as documented on our
#   developer web site.
#   </dd>
# 
# <dt>stack</dt>
#   <dd>If this is set, then the notebook is visually contained within a stack
#   of notebooks with this name.  All notebooks in the same account with the
#   same 'stack' field are considered to be in the same stack.
#   Notebooks with no stack set are "top level" and not contained within a
#   stack.  The link owner can change this and this field is for the benefit
#   of the link owner.
#   </dd>
# 
# <dt>businessId</dt>
#   <dd>If set, this will be the unique identifier for the business that owns
#   the notebook to which the linked notebook refers.
# 
# </dl>
      class LinkedNotebook
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SHARENAME = 2
        USERNAME = 3
        SHARDID = 4
        SHAREKEY = 5
        URI = 6
        GUID = 7
        UPDATESEQUENCENUM = 8
        NOTESTOREURL = 9
        WEBAPIURLPREFIX = 10
        STACK = 11
        BUSINESSID = 12

        FIELDS = {
          SHARENAME => {:type => ::Thrift::Types::STRING, :name => 'shareName', :optional => true},
          USERNAME => {:type => ::Thrift::Types::STRING, :name => 'username', :optional => true},
          SHARDID => {:type => ::Thrift::Types::STRING, :name => 'shardId', :optional => true},
          SHAREKEY => {:type => ::Thrift::Types::STRING, :name => 'shareKey', :optional => true},
          URI => {:type => ::Thrift::Types::STRING, :name => 'uri', :optional => true},
          GUID => {:type => ::Thrift::Types::STRING, :name => 'guid', :optional => true},
          UPDATESEQUENCENUM => {:type => ::Thrift::Types::I32, :name => 'updateSequenceNum', :optional => true},
          NOTESTOREURL => {:type => ::Thrift::Types::STRING, :name => 'noteStoreUrl', :optional => true},
          WEBAPIURLPREFIX => {:type => ::Thrift::Types::STRING, :name => 'webApiUrlPrefix', :optional => true},
          STACK => {:type => ::Thrift::Types::STRING, :name => 'stack', :optional => true},
          BUSINESSID => {:type => ::Thrift::Types::I32, :name => 'businessId', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A structure that describes a notebook or a user's relationship with
# a notebook. NotebookDescriptor is expected to remain a lighter-weight
# structure when compared to Notebook.
# <dl>
# <dt>guid</dt>
#   <dd>The unique identifier of the notebook.
#   </dd>
# 
# <dt>notebookDisplayName</dt>
#   <dd>A sequence of characters representing the name of the
#   notebook.
#   </dd>
# 
# <dt>contactName</dt>
#   <dd>The User.name value of the notebook's "contact".
#   </dd>
# 
# <dt>hasSharedNotebook</dt>
#   <dd>Whether a SharedNotebook record exists between the calling user and this
#   notebook.
#   </dd>
# 
# <dt>joinedUserCount</dt>
#   <dd>The number of users who have joined this notebook.
#   </dd>
# 
# </dl>
      class NotebookDescriptor
        include ::Thrift::Struct, ::Thrift::Struct_Union
        GUID = 1
        NOTEBOOKDISPLAYNAME = 2
        CONTACTNAME = 3
        HASSHAREDNOTEBOOK = 4
        JOINEDUSERCOUNT = 5

        FIELDS = {
          GUID => {:type => ::Thrift::Types::STRING, :name => 'guid', :optional => true},
          NOTEBOOKDISPLAYNAME => {:type => ::Thrift::Types::STRING, :name => 'notebookDisplayName', :optional => true},
          CONTACTNAME => {:type => ::Thrift::Types::STRING, :name => 'contactName', :optional => true},
          HASSHAREDNOTEBOOK => {:type => ::Thrift::Types::BOOL, :name => 'hasSharedNotebook', :optional => true},
          JOINEDUSERCOUNT => {:type => ::Thrift::Types::I32, :name => 'joinedUserCount', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

    end
  end
end
