#
# Autogenerated by Thrift Compiler (0.5.0-en-exported)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require 'limits_types'


module Evernote
  module EDAM
    module Type
      module PrivilegeLevel
        NORMAL = 1
        PREMIUM = 3
        VIP = 5
        MANAGER = 7
        SUPPORT = 8
        ADMIN = 9
        VALUE_MAP = {1 => "NORMAL", 3 => "PREMIUM", 5 => "VIP", 7 => "MANAGER", 8 => "SUPPORT", 9 => "ADMIN"}
        VALID_VALUES = Set.new([NORMAL, PREMIUM, VIP, MANAGER, SUPPORT, ADMIN]).freeze
      end

      module ServiceLevel
        BASIC = 1
        PLUS = 2
        PREMIUM = 3
        VALUE_MAP = {1 => "BASIC", 2 => "PLUS", 3 => "PREMIUM"}
        VALID_VALUES = Set.new([BASIC, PLUS, PREMIUM]).freeze
      end

      module QueryFormat
        USER = 1
        SEXP = 2
        VALUE_MAP = {1 => "USER", 2 => "SEXP"}
        VALID_VALUES = Set.new([USER, SEXP]).freeze
      end

      module NoteSortOrder
        CREATED = 1
        UPDATED = 2
        RELEVANCE = 3
        UPDATE_SEQUENCE_NUMBER = 4
        TITLE = 5
        VALUE_MAP = {1 => "CREATED", 2 => "UPDATED", 3 => "RELEVANCE", 4 => "UPDATE_SEQUENCE_NUMBER", 5 => "TITLE"}
        VALID_VALUES = Set.new([CREATED, UPDATED, RELEVANCE, UPDATE_SEQUENCE_NUMBER, TITLE]).freeze
      end

      module PremiumOrderStatus
        NONE = 0
        PENDING = 1
        ACTIVE = 2
        FAILED = 3
        CANCELLATION_PENDING = 4
        CANCELED = 5
        VALUE_MAP = {0 => "NONE", 1 => "PENDING", 2 => "ACTIVE", 3 => "FAILED", 4 => "CANCELLATION_PENDING", 5 => "CANCELED"}
        VALID_VALUES = Set.new([NONE, PENDING, ACTIVE, FAILED, CANCELLATION_PENDING, CANCELED]).freeze
      end

      module SharedNotebookPrivilegeLevel
        READ_NOTEBOOK = 0
        MODIFY_NOTEBOOK_PLUS_ACTIVITY = 1
        READ_NOTEBOOK_PLUS_ACTIVITY = 2
        GROUP = 3
        FULL_ACCESS = 4
        BUSINESS_FULL_ACCESS = 5
        VALUE_MAP = {0 => "READ_NOTEBOOK", 1 => "MODIFY_NOTEBOOK_PLUS_ACTIVITY", 2 => "READ_NOTEBOOK_PLUS_ACTIVITY", 3 => "GROUP", 4 => "FULL_ACCESS", 5 => "BUSINESS_FULL_ACCESS"}
        VALID_VALUES = Set.new([READ_NOTEBOOK, MODIFY_NOTEBOOK_PLUS_ACTIVITY, READ_NOTEBOOK_PLUS_ACTIVITY, GROUP, FULL_ACCESS, BUSINESS_FULL_ACCESS]).freeze
      end

      module SharedNotePrivilegeLevel
        READ_NOTE = 0
        MODIFY_NOTE = 1
        FULL_ACCESS = 2
        VALUE_MAP = {0 => "READ_NOTE", 1 => "MODIFY_NOTE", 2 => "FULL_ACCESS"}
        VALID_VALUES = Set.new([READ_NOTE, MODIFY_NOTE, FULL_ACCESS]).freeze
      end

      module SponsoredGroupRole
        GROUP_MEMBER = 1
        GROUP_ADMIN = 2
        GROUP_OWNER = 3
        VALUE_MAP = {1 => "GROUP_MEMBER", 2 => "GROUP_ADMIN", 3 => "GROUP_OWNER"}
        VALID_VALUES = Set.new([GROUP_MEMBER, GROUP_ADMIN, GROUP_OWNER]).freeze
      end

      module BusinessUserRole
        ADMIN = 1
        NORMAL = 2
        VALUE_MAP = {1 => "ADMIN", 2 => "NORMAL"}
        VALID_VALUES = Set.new([ADMIN, NORMAL]).freeze
      end

      module SharedNotebookInstanceRestrictions
        ONLY_JOINED_OR_PREVIEW = 1
        NO_SHARED_NOTEBOOKS = 2
        VALUE_MAP = {1 => "ONLY_JOINED_OR_PREVIEW", 2 => "NO_SHARED_NOTEBOOKS"}
        VALID_VALUES = Set.new([ONLY_JOINED_OR_PREVIEW, NO_SHARED_NOTEBOOKS]).freeze
      end

      module ReminderEmailConfig
        DO_NOT_SEND = 1
        SEND_DAILY_EMAIL = 2
        VALUE_MAP = {1 => "DO_NOT_SEND", 2 => "SEND_DAILY_EMAIL"}
        VALID_VALUES = Set.new([DO_NOT_SEND, SEND_DAILY_EMAIL]).freeze
      end

      module BusinessInvitationStatus
        APPROVED = 0
        REQUESTED = 1
        REDEEMED = 2
        VALUE_MAP = {0 => "APPROVED", 1 => "REQUESTED", 2 => "REDEEMED"}
        VALID_VALUES = Set.new([APPROVED, REQUESTED, REDEEMED]).freeze
      end

      module ContactType
        EVERNOTE = 1
        SMS = 2
        FACEBOOK = 3
        EMAIL = 4
        TWITTER = 5
        LINKEDIN = 6
        VALUE_MAP = {1 => "EVERNOTE", 2 => "SMS", 3 => "FACEBOOK", 4 => "EMAIL", 5 => "TWITTER", 6 => "LINKEDIN"}
        VALID_VALUES = Set.new([EVERNOTE, SMS, FACEBOOK, EMAIL, TWITTER, LINKEDIN]).freeze
      end

      module RelatedContentType
        NEWS_ARTICLE = 1
        PROFILE_PERSON = 2
        PROFILE_ORGANIZATION = 3
        REFERENCE_MATERIAL = 4
        VALUE_MAP = {1 => "NEWS_ARTICLE", 2 => "PROFILE_PERSON", 3 => "PROFILE_ORGANIZATION", 4 => "REFERENCE_MATERIAL"}
        VALID_VALUES = Set.new([NEWS_ARTICLE, PROFILE_PERSON, PROFILE_ORGANIZATION, REFERENCE_MATERIAL]).freeze
      end

      module RelatedContentAccess
        NOT_ACCESSIBLE = 0
        DIRECT_LINK_ACCESS_OK = 1
        DIRECT_LINK_LOGIN_REQUIRED = 2
        DIRECT_LINK_EMBEDDED_VIEW = 3
        VALUE_MAP = {0 => "NOT_ACCESSIBLE", 1 => "DIRECT_LINK_ACCESS_OK", 2 => "DIRECT_LINK_LOGIN_REQUIRED", 3 => "DIRECT_LINK_EMBEDDED_VIEW"}
        VALID_VALUES = Set.new([NOT_ACCESSIBLE, DIRECT_LINK_ACCESS_OK, DIRECT_LINK_LOGIN_REQUIRED, DIRECT_LINK_EMBEDDED_VIEW]).freeze
      end

      module UserIdentityType
        EVERNOTE_USERID = 1
        EMAIL = 2
        IDENTITYID = 3
        VALUE_MAP = {1 => "EVERNOTE_USERID", 2 => "EMAIL", 3 => "IDENTITYID"}
        VALID_VALUES = Set.new([EVERNOTE_USERID, EMAIL, IDENTITYID]).freeze
      end

      #  In several places, EDAM exchanges blocks of bytes of data for a component
#  which may be relatively large.  For example:  the contents of a clipped
#  HTML note, the bytes of an embedded image, or the recognition XML for
#  a large image.  This structure is used in the protocol to represent
#  any of those large blocks of data when they are transmitted or when
#  they are only referenced their metadata.
# 
# <dl>
#  <dt>bodyHash</dt>
#    <dd>This field carries a one-way hash of the contents of the
#    data body, in binary form.  The hash function is MD5<br/>
#    Length:  EDAM_HASH_LEN (exactly)
#    </dd>
# 
#  <dt>size</dt>
#    <dd>The length, in bytes, of the data body.
#    </dd>
# 
#  <dt>body</dt>
#    <dd>This field is set to contain the binary contents of the data
#    whenever the resource is being transferred.  If only metadata is
#    being exchanged, this field will be empty.  For example, a client could
#    notify the service about the change to an attribute for a resource
#    without transmitting the binary resource contents.
#    </dd>
#  </dl>
      class Data
        include ::Thrift::Struct, ::Thrift::Struct_Union
        BODYHASH = 1
        SIZE = 2
        BODY = 3

        FIELDS = {
          BODYHASH => {:type => ::Thrift::Types::STRING, :name => 'bodyHash', :binary => true, :optional => true},
          SIZE => {:type => ::Thrift::Types::I32, :name => 'size', :optional => true},
          BODY => {:type => ::Thrift::Types::STRING, :name => 'body', :binary => true, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      #  A structure holding the optional attributes that can be stored
#  on a User.  These are generally less critical than the core User fields.
# 
# <dl>
#  <dt>defaultLocationName</dt>
#    <dd>the location string that should be associated
#    with the user in order to determine where notes are taken if not otherwise
#    specified.<br/>
#    Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#    </dd>
# 
#  <dt>defaultLatitude</dt>
#    <dd>if set, this is the latitude that should be
#    assigned to any notes that have no other latitude information.
#    </dd>
# 
#  <dt>defaultLongitude</dt>
#    <dd>if set, this is the longitude that should be
#    assigned to any notes that have no other longitude information.
#    </dd>
# 
#  <dt>preactivation</dt>
#    <dd>if set, the user account is not yet confirmed for
#    login.  I.e. the account has been created, but we are still waiting for
#    the user to complete the activation step.
#    </dd>
# 
#  <dt>viewedPromotions</dt>
#    <dd>a list of promotions the user has seen.
#     This list may occasionally be modified by the system when promotions are
#     no longer available.<br/>
#     Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#    </dd>
# 
#  <dt>incomingEmailAddress</dt>
#    <dd>if set, this is the email address that the
#     user may send email to in order to add an email note directly into the
#     account via the SMTP email gateway.  This is the part of the email
#     address before the '@' symbol ... our domain is not included.
#     If this is not set, the user may not add notes via the gateway.<br/>
#     Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#    </dd>
# 
#  <dt>recentMailedAddresses</dt>
#    <dd>if set, this will contain a list of email
#     addresses that have recently been used as recipients
#     of outbound emails by the user.  This can be used to pre-populate a
#     list of possible destinations when a user wishes to send a note via
#     email.<br/>
#     Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX each<br/>
#     Max:  EDAM_USER_RECENT_MAILED_ADDRESSES_MAX entries
#    </dd>
# 
#  <dt>comments</dt>
#    <dd>Free-form text field that may hold general support
#     information, etc.<br/>
#     Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#    </dd>
# 
#  <dt>dateAgreedToTermsOfService</dt>
#    <dd>The date/time when the user agreed to
#     the terms of service.  This can be used as the effective "start date"
#     for the account.
#    </dd>
# 
#  <dt>maxReferrals</dt>
#    <dd>The number of referrals that the user is permitted
#     to make.
#    </dd>
# 
#  <dt>referralCount</dt>
#    <dd>The number of referrals sent from this account.
#    </dd>
# 
#  <dt>refererCode</dt>
#    <dd>A code indicating where the user was sent from. AKA
#     promotion code
#    </dd>
# 
#  <dt>sentEmailDate</dt>
#    <dd>The most recent date when the user sent outbound
#     emails from the service.  Used with sentEmailCount to limit the number
#     of emails that can be sent per day.
#    </dd>
# 
#  <dt>sentEmailCount</dt>
#    <dd>The number of emails that were sent from the user
#     via the service on sentEmailDate.  Used to enforce a limit on the number
#     of emails per user per day to prevent spamming.
#    </dd>
# 
#  <dt>dailyEmailLimit</dt>
#    <dd>If set, this is the maximum number of emails that
#     may be sent in a given day from this account.  If unset, the server will
#     use the configured default limit.
#    </dd>
# 
#  <dt>emailOptOutDate</dt>
#    <dd>If set, this is the date when the user asked
#     to be excluded from offers and promotions sent by Evernote.  If not set,
#     then the user currently agrees to receive these messages.
#    </dd>
# 
#  <dt>partnerEmailOptInDate</dt>
#    <dd>If set, this is the date when the user asked
#     to be included in offers and promotions sent by Evernote's partners.
#     If not sent, then the user currently does not agree to receive these
#     emails.
#    </dd>
# 
#  <dt>preferredLanguage</dt>
#    <dd>a 2 character language codes based on:
#        http://ftp.ics.uci.edu/pub/ietf/http/related/iso639.txt used for
#       localization purposes to determine what language to use for the web
#       interface and for other direct communication (e.g. emails).
#    </dd>
# 
#  <dt>preferredCountry</dt>
#    <dd>Preferred country code based on ISO 3166-1-alpha-2 indicating the
#    users preferred country</dd>
# 
#  <dt>clipFullPage</dt>
#    <dd>Boolean flag set to true if the user wants to clip full pages by
#    default when they use the web clipper without a selection.</dd>
# 
#  <dt>twitterUserName</dt>
#    <dd>The username of the account of someone who has chosen to enable
#    Twittering into Evernote.  This value is subject to change, since users
#    may change their Twitter user name.</dd>
# 
#  <dt>twitterId</dt>
#    <dd>The unique identifier of the user's Twitter account if that user
#    has chosen to enable Twittering into Evernote.</dd>
# 
#  <dt>groupName</dt>
#    <dd>A name identifier used to identify a particular set of branding and
#     light customization.</dd>
# 
#  <dt>recognitionLanguage</dt>
#    <dd>a 2 character language codes based on:
#        http://ftp.ics.uci.edu/pub/ietf/http/related/iso639.txt
#        If set, this is used to determine the language that should be used
#        when processing images and PDF files to find text.
#        If not set, then the 'preferredLanguage' will be used.
#    </dd>
# 
#  <dt>educationalInstitution</dt>
#    <dd>a flag indicating that the user is part of an educational institution which
#    makes them eligible for discounts on bulk purchases
#    </dd>
# 
#  <dt>businessAddress</dt>
#    <dd>A string recording the business address of a Sponsored Account user who has requested invoicing.
#    </dd>
# 
#  <dt>hideSponsorBilling</dt>
#    <dd>A flag indicating whether to hide the billing information on a sponsored
#        account owner's settings page
#    </dd>
# 
#  <dt>taxExempt</dt>
#    <dd><i>DEPRECATED:</i>A flag indicating the user's sponsored group is exempt from sale tax
#    </dd>
# 
#  <dt>useEmailAutoFiling</dt>
#    <dd>A flag indicating whether the user chooses to allow Evernote to automatically
#        file and tag emailed notes
#    </dd>
# 
#  <dt>reminderEmailConfig</dt>
#    <dd>Configuration state for whether or not the user wishes to receive
#        reminder e-mail.  This setting applies to both the reminder e-mail sent
#        for personal reminder notes and for the reminder e-mail sent for reminder
#        notes in the user's business notebooks that the user has configured for
#        e-mail notifications.
#    </dd>
# 
#  <dt>emailAddressLastConfirmed</dt>
#    <dd>If set, this contains the time at which the user last confirmed that the
#        configured email address for this account is correct and up-to-date. If this is
#        unset that indicates that the user's email address is unverified.
#    </dd>
# 
#  <dt>passwordUpdated</dt>
#    <dd>If set, this contains the time at which the user's password last changed. This
#        will be unset for users created before the addition of this field who have not
#        changed their passwords since the addition of this field.
#    </dd>
# 
#  </dl>
      class UserAttributes
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DEFAULTLOCATIONNAME = 1
        DEFAULTLATITUDE = 2
        DEFAULTLONGITUDE = 3
        PREACTIVATION = 4
        VIEWEDPROMOTIONS = 5
        INCOMINGEMAILADDRESS = 6
        RECENTMAILEDADDRESSES = 7
        COMMENTS = 9
        DATEAGREEDTOTERMSOFSERVICE = 11
        MAXREFERRALS = 12
        REFERRALCOUNT = 13
        REFERERCODE = 14
        SENTEMAILDATE = 15
        SENTEMAILCOUNT = 16
        DAILYEMAILLIMIT = 17
        EMAILOPTOUTDATE = 18
        PARTNEREMAILOPTINDATE = 19
        PREFERREDLANGUAGE = 20
        PREFERREDCOUNTRY = 21
        CLIPFULLPAGE = 22
        TWITTERUSERNAME = 23
        TWITTERID = 24
        GROUPNAME = 25
        RECOGNITIONLANGUAGE = 26
        REFERRALPROOF = 28
        EDUCATIONALDISCOUNT = 29
        BUSINESSADDRESS = 30
        HIDESPONSORBILLING = 31
        TAXEXEMPT = 32
        USEEMAILAUTOFILING = 33
        REMINDEREMAILCONFIG = 34
        EMAILADDRESSLASTCONFIRMED = 35
        PASSWORDUPDATED = 36

        FIELDS = {
          DEFAULTLOCATIONNAME => {:type => ::Thrift::Types::STRING, :name => 'defaultLocationName', :optional => true},
          DEFAULTLATITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'defaultLatitude', :optional => true},
          DEFAULTLONGITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'defaultLongitude', :optional => true},
          PREACTIVATION => {:type => ::Thrift::Types::BOOL, :name => 'preactivation', :optional => true},
          VIEWEDPROMOTIONS => {:type => ::Thrift::Types::LIST, :name => 'viewedPromotions', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          INCOMINGEMAILADDRESS => {:type => ::Thrift::Types::STRING, :name => 'incomingEmailAddress', :optional => true},
          RECENTMAILEDADDRESSES => {:type => ::Thrift::Types::LIST, :name => 'recentMailedAddresses', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          COMMENTS => {:type => ::Thrift::Types::STRING, :name => 'comments', :optional => true},
          DATEAGREEDTOTERMSOFSERVICE => {:type => ::Thrift::Types::I64, :name => 'dateAgreedToTermsOfService', :optional => true},
          MAXREFERRALS => {:type => ::Thrift::Types::I32, :name => 'maxReferrals', :optional => true},
          REFERRALCOUNT => {:type => ::Thrift::Types::I32, :name => 'referralCount', :optional => true},
          REFERERCODE => {:type => ::Thrift::Types::STRING, :name => 'refererCode', :optional => true},
          SENTEMAILDATE => {:type => ::Thrift::Types::I64, :name => 'sentEmailDate', :optional => true},
          SENTEMAILCOUNT => {:type => ::Thrift::Types::I32, :name => 'sentEmailCount', :optional => true},
          DAILYEMAILLIMIT => {:type => ::Thrift::Types::I32, :name => 'dailyEmailLimit', :optional => true},
          EMAILOPTOUTDATE => {:type => ::Thrift::Types::I64, :name => 'emailOptOutDate', :optional => true},
          PARTNEREMAILOPTINDATE => {:type => ::Thrift::Types::I64, :name => 'partnerEmailOptInDate', :optional => true},
          PREFERREDLANGUAGE => {:type => ::Thrift::Types::STRING, :name => 'preferredLanguage', :optional => true},
          PREFERREDCOUNTRY => {:type => ::Thrift::Types::STRING, :name => 'preferredCountry', :optional => true},
          CLIPFULLPAGE => {:type => ::Thrift::Types::BOOL, :name => 'clipFullPage', :optional => true},
          TWITTERUSERNAME => {:type => ::Thrift::Types::STRING, :name => 'twitterUserName', :optional => true},
          TWITTERID => {:type => ::Thrift::Types::STRING, :name => 'twitterId', :optional => true},
          GROUPNAME => {:type => ::Thrift::Types::STRING, :name => 'groupName', :optional => true},
          RECOGNITIONLANGUAGE => {:type => ::Thrift::Types::STRING, :name => 'recognitionLanguage', :optional => true},
          REFERRALPROOF => {:type => ::Thrift::Types::STRING, :name => 'referralProof', :optional => true},
          EDUCATIONALDISCOUNT => {:type => ::Thrift::Types::BOOL, :name => 'educationalDiscount', :optional => true},
          BUSINESSADDRESS => {:type => ::Thrift::Types::STRING, :name => 'businessAddress', :optional => true},
          HIDESPONSORBILLING => {:type => ::Thrift::Types::BOOL, :name => 'hideSponsorBilling', :optional => true},
          TAXEXEMPT => {:type => ::Thrift::Types::BOOL, :name => 'taxExempt', :optional => true},
          USEEMAILAUTOFILING => {:type => ::Thrift::Types::BOOL, :name => 'useEmailAutoFiling', :optional => true},
          REMINDEREMAILCONFIG => {:type => ::Thrift::Types::I32, :name => 'reminderEmailConfig', :optional => true, :enum_class => ::Evernote::EDAM::Type::ReminderEmailConfig},
          EMAILADDRESSLASTCONFIRMED => {:type => ::Thrift::Types::I64, :name => 'emailAddressLastConfirmed', :optional => true},
          PASSWORDUPDATED => {:type => ::Thrift::Types::I64, :name => 'passwordUpdated', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @reminderEmailConfig.nil? || ::Evernote::EDAM::Type::ReminderEmailConfig::VALID_VALUES.include?(@reminderEmailConfig)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field reminderEmailConfig!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A structure holding the optional attributes associated with users
# in a business.
# 
# <dl>
#  <dt>title</dt>
#  <dd>Free form text of this user's title in the business</dd>
# 
#  <dt>location</dt>
#  <dd>City, State (for US) or City / Province for other countries</dd>
# 
#  <dt>department</dt>
#  <dd>Free form text of the department this user belongs to.</dd>
# 
#  <dt>mobilePhone</dt>
#  <dd>User's mobile phone number. Stored as plain text without any formatting.</dd>
# 
#  <dt>linkedInProfileUrl</dt>
#  <dd>URL to user's public LinkedIn profile page. This should only contain
#  the portion relative to the base LinkedIn URL. For example: "/pub/john-smith/".
#  </dd>
# 
#  <dt>workPhone</dt>
#  <dd>User's work phone number. Stored as plain text without any formatting.</dd>
# 
#  <dt>companyStartDate</dt>
#  <dd>The date on which the user started working at their company.</dd>
# </dl>
      class BusinessUserAttributes
        include ::Thrift::Struct, ::Thrift::Struct_Union
        TITLE = 1
        LOCATION = 2
        DEPARTMENT = 3
        MOBILEPHONE = 4
        LINKEDINPROFILEURL = 5
        WORKPHONE = 6
        COMPANYSTARTDATE = 7

        FIELDS = {
          TITLE => {:type => ::Thrift::Types::STRING, :name => 'title', :optional => true},
          LOCATION => {:type => ::Thrift::Types::STRING, :name => 'location', :optional => true},
          DEPARTMENT => {:type => ::Thrift::Types::STRING, :name => 'department', :optional => true},
          MOBILEPHONE => {:type => ::Thrift::Types::STRING, :name => 'mobilePhone', :optional => true},
          LINKEDINPROFILEURL => {:type => ::Thrift::Types::STRING, :name => 'linkedInProfileUrl', :optional => true},
          WORKPHONE => {:type => ::Thrift::Types::STRING, :name => 'workPhone', :optional => true},
          COMPANYSTARTDATE => {:type => ::Thrift::Types::I64, :name => 'companyStartDate', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Defines backup payment information for a subscription user - to be used at a
# designated time in the future such as when their current payment method expires.
# 
# <dl>
# <dt>premiumCommerceService</dt>
#     <dd>Commerce service of backup payment. Must be 'ADYEN_CC'.</dd>
# <dt>premiumServiceSKU</dt>
#     <dd>Sku code of desired subscription to be purchased. May or may not
#     be the same as the current subscription sku.
#     </dd>
# <dt>currency</dt>
#     <dd>Currency code for backup payment charge.</dd>
# <dt>unitPrice</dt>
#     <dd>Unit price for backup payment charge.</dd>
# <dt>paymentMethodId</dt>
#     <dd>Id of the payment method to bill against.</dd>
# </dl>
      class BackupPaymentInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PREMIUMCOMMERCESERVICE = 1
        PREMIUMSERVICESKU = 2
        CURRENCY = 3
        UNITPRICE = 4
        PAYMENTMETHODID = 5

        FIELDS = {
          PREMIUMCOMMERCESERVICE => {:type => ::Thrift::Types::STRING, :name => 'premiumCommerceService'},
          PREMIUMSERVICESKU => {:type => ::Thrift::Types::STRING, :name => 'premiumServiceSKU'},
          CURRENCY => {:type => ::Thrift::Types::STRING, :name => 'currency'},
          UNITPRICE => {:type => ::Thrift::Types::I32, :name => 'unitPrice'},
          PAYMENTMETHODID => {:type => ::Thrift::Types::I32, :name => 'paymentMethodId'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field premiumCommerceService is unset!') unless @premiumCommerceService
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field premiumServiceSKU is unset!') unless @premiumServiceSKU
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field currency is unset!') unless @currency
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field unitPrice is unset!') unless @unitPrice
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field paymentMethodId is unset!') unless @paymentMethodId
        end

        ::Thrift::Struct.generate_accessors self
      end

      #  This represents the bookkeeping information for the user's subscription.
# 
# <dl>
#  <dt>uploadLimitEnd</dt>
#    <dd>The date and time when the current upload limit
#    expires.  At this time, the monthly upload count reverts to 0 and a new
#    limit is imposed.  This date and time is exclusive, so this is effectively
#    the start of the new month.
#    </dd>
#  <dt>uploadLimitNextMonth</dt>
#    <dd> When uploadLimitEnd is reached, the service
#    will change uploadLimit to uploadLimitNextMonth. If a premium account is
#    canceled, this mechanism will reset the quota appropriately.
#    </dd>
#  <dt>premiumServiceStatus</dt>
#    <dd>Indicates the phases of a premium account
#    during the billing process.
#    </dd>
#  <dt>premiumOrderNumber</dt>
#    <dd>The order number used by the commerce system to
#    process recurring payments
#    </dd>
#  <dt>premiumServiceStart</dt>
#    <dd>The start date when this premium promotion
#    began (this number will get overwritten if a premium service is canceled
#    and then re-activated).
#    </dd>
#  <dt>premiumCommerceService</dt>
#    <dd>The commerce system used (paypal, Google
#    checkout, etc)
#    </dd>
#  <dt>premiumServiceSKU</dt>
#    <dd>The code associated with the purchase eg. monthly
#    or annual purchase. Clients should interpret this value and localize it.
#    </dd>
#  <dt>lastSuccessfulCharge</dt>
#    <dd>Date the last time the user was charged.
#    Null if never charged.
#    </dd>
#  <dt>lastFailedCharge</dt>
#    <dd>Date the last time a charge was attempted and
#    failed.
#    </dd>
#  <dt>lastFailedChargeReason</dt>
#    <dd>Reason provided for the charge failure
#    </dd>
#  <dt>nextPaymentDue</dt>
#    <dd>The end of the billing cycle. This could be in the
#    past if there are failed charges.
#    </dd>
#  <dt>premiumLockUntil</dt>
#    <dd>An internal variable to manage locking operations
#    on the commerce variables.
#    </dd>
#  <dt>updated</dt>
#    <dd>The date any modification where made to this record.
#    </dd>
#  <dt>premiumSubscriptionNumber</dt>
#    <dd>The number number identifying the
#    recurring subscription used to make the recurring charges.
#    </dd>
#  <dt>lastRequestedCharge</dt>
#    <dd>Date charge last attempted</dd>
#  <dt>currency</dt>
#    <dd>ISO 4217 currency code</dd>
#  <dt>unitPrice</dt>
#    <dd>charge in the smallest unit of the currency (e.g. cents for USD)</dd>
#  <dt>businessId</dt>
#    <dd><i>DEPRECATED:</i>See BusinessUserInfo.</dd>
#  <dt>businessName</dt>
#    <dd><i>DEPRECATED:</i>See BusinessUserInfo.</dd>
#  <dt>businessRole</dt>
#    <dd><i>DEPRECATED:</i>See BusinessUserInfo.</dd>
#  <dt>unitDiscount</dt>
#    <dd>discount per seat in negative amount and smallest unit of the currency (e.g.
#        cents for USD)</dd>
#  <dt>nextChargeDate</dt>
#    <dd>The next time the user will be charged, may or may not be the same as
#        nextPaymentDue</dd>
#  <dt>backupPaymentInfo</dt>
#    <dd>Contains backup payment information that can be used as a fallback should the
#        current payment method expire.</dd>
#  </dl>
      class Accounting
        include ::Thrift::Struct, ::Thrift::Struct_Union
        UPLOADLIMITEND = 2
        UPLOADLIMITNEXTMONTH = 3
        PREMIUMSERVICESTATUS = 4
        PREMIUMORDERNUMBER = 5
        PREMIUMCOMMERCESERVICE = 6
        PREMIUMSERVICESTART = 7
        PREMIUMSERVICESKU = 8
        LASTSUCCESSFULCHARGE = 9
        LASTFAILEDCHARGE = 10
        LASTFAILEDCHARGEREASON = 11
        NEXTPAYMENTDUE = 12
        PREMIUMLOCKUNTIL = 13
        UPDATED = 14
        PREMIUMSUBSCRIPTIONNUMBER = 16
        LASTREQUESTEDCHARGE = 17
        CURRENCY = 18
        UNITPRICE = 19
        BUSINESSID = 20
        BUSINESSNAME = 21
        BUSINESSROLE = 22
        UNITDISCOUNT = 23
        NEXTCHARGEDATE = 24
        AVAILABLEPOINTS = 25
        BACKUPPAYMENTINFO = 26

        FIELDS = {
          UPLOADLIMITEND => {:type => ::Thrift::Types::I64, :name => 'uploadLimitEnd', :optional => true},
          UPLOADLIMITNEXTMONTH => {:type => ::Thrift::Types::I64, :name => 'uploadLimitNextMonth', :optional => true},
          PREMIUMSERVICESTATUS => {:type => ::Thrift::Types::I32, :name => 'premiumServiceStatus', :optional => true, :enum_class => ::Evernote::EDAM::Type::PremiumOrderStatus},
          PREMIUMORDERNUMBER => {:type => ::Thrift::Types::STRING, :name => 'premiumOrderNumber', :optional => true},
          PREMIUMCOMMERCESERVICE => {:type => ::Thrift::Types::STRING, :name => 'premiumCommerceService', :optional => true},
          PREMIUMSERVICESTART => {:type => ::Thrift::Types::I64, :name => 'premiumServiceStart', :optional => true},
          PREMIUMSERVICESKU => {:type => ::Thrift::Types::STRING, :name => 'premiumServiceSKU', :optional => true},
          LASTSUCCESSFULCHARGE => {:type => ::Thrift::Types::I64, :name => 'lastSuccessfulCharge', :optional => true},
          LASTFAILEDCHARGE => {:type => ::Thrift::Types::I64, :name => 'lastFailedCharge', :optional => true},
          LASTFAILEDCHARGEREASON => {:type => ::Thrift::Types::STRING, :name => 'lastFailedChargeReason', :optional => true},
          NEXTPAYMENTDUE => {:type => ::Thrift::Types::I64, :name => 'nextPaymentDue', :optional => true},
          PREMIUMLOCKUNTIL => {:type => ::Thrift::Types::I64, :name => 'premiumLockUntil', :optional => true},
          UPDATED => {:type => ::Thrift::Types::I64, :name => 'updated', :optional => true},
          PREMIUMSUBSCRIPTIONNUMBER => {:type => ::Thrift::Types::STRING, :name => 'premiumSubscriptionNumber', :optional => true},
          LASTREQUESTEDCHARGE => {:type => ::Thrift::Types::I64, :name => 'lastRequestedCharge', :optional => true},
          CURRENCY => {:type => ::Thrift::Types::STRING, :name => 'currency', :optional => true},
          UNITPRICE => {:type => ::Thrift::Types::I32, :name => 'unitPrice', :optional => true},
          BUSINESSID => {:type => ::Thrift::Types::I32, :name => 'businessId', :optional => true},
          BUSINESSNAME => {:type => ::Thrift::Types::STRING, :name => 'businessName', :optional => true},
          BUSINESSROLE => {:type => ::Thrift::Types::I32, :name => 'businessRole', :optional => true, :enum_class => ::Evernote::EDAM::Type::BusinessUserRole},
          UNITDISCOUNT => {:type => ::Thrift::Types::I32, :name => 'unitDiscount', :optional => true},
          NEXTCHARGEDATE => {:type => ::Thrift::Types::I64, :name => 'nextChargeDate', :optional => true},
          AVAILABLEPOINTS => {:type => ::Thrift::Types::I32, :name => 'availablePoints', :optional => true},
          BACKUPPAYMENTINFO => {:type => ::Thrift::Types::STRUCT, :name => 'backupPaymentInfo', :class => ::Evernote::EDAM::Type::BackupPaymentInfo, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @premiumServiceStatus.nil? || ::Evernote::EDAM::Type::PremiumOrderStatus::VALID_VALUES.include?(@premiumServiceStatus)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field premiumServiceStatus!')
          end
          unless @businessRole.nil? || ::Evernote::EDAM::Type::BusinessUserRole::VALID_VALUES.include?(@businessRole)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field businessRole!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # This structure is used to provide information about an Evernote Business
# membership, for members who are part of a business.
# 
# <dl>
# <dt>businessId</dt>
#   <dd>The ID of the Evernote Business account that the user is a member of.
# <dt>businessName</dt>
#   <dd>The human-readable name of the Evernote Business account that the user
#       is a member of.</dd>
# <dt>role</dt>
#   <dd>The role of the user within the Evernote Business account that
#       they are a member of.</dd>
# <dt>email</dt>
#   <dd>An e-mail address that will be used by the service in the context of your
#       Evernote Business activities.  For example, this e-mail address will be used
#       when you e-mail a business note, when you update notes in the account of
#       your business, etc.  The business e-mail cannot be used for identification
#       purposes such as for logging into the service.
#   </dd>
# <dt>updated</dt>
#   <dd>Last time the business user or business user attributes were updated.</dd>
# </dl>
      class BusinessUserInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        BUSINESSID = 1
        BUSINESSNAME = 2
        ROLE = 3
        EMAIL = 4
        UPDATED = 5

        FIELDS = {
          BUSINESSID => {:type => ::Thrift::Types::I32, :name => 'businessId', :optional => true},
          BUSINESSNAME => {:type => ::Thrift::Types::STRING, :name => 'businessName', :optional => true},
          ROLE => {:type => ::Thrift::Types::I32, :name => 'role', :optional => true, :enum_class => ::Evernote::EDAM::Type::BusinessUserRole},
          EMAIL => {:type => ::Thrift::Types::STRING, :name => 'email', :optional => true},
          UPDATED => {:type => ::Thrift::Types::I64, :name => 'updated', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @role.nil? || ::Evernote::EDAM::Type::BusinessUserRole::VALID_VALUES.include?(@role)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field role!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      #  This structure is used to provide account limits that are in effect for this user.
# <dl>
#  <dt>userMailLimitDaily</dt>
#    <dd>The number of emails of any type that can be sent by a user from the
#        service per day.  If an email is sent to two different recipients, this
#        counts as two emails.
#    </dd>
#  <dt>noteSizeMax</dt>
#    <dd>Maximum total size of a Note that can be added.  The size of a note is
#        calculated as:
#        ENML content length (in Unicode characters) plus the sum of all resource
#        sizes (in bytes).
#    </dd>
#  <dt>resourceSizeMax</dt>
#    <dd>Maximum size of a resource, in bytes
#    </dd>
#  <dt>userLinkedNotebookMax</dt>
#    <dd>Maximum number of linked notebooks per account.
#    </dd>
#  <dt>uploadLimit</dt>
#    <dd>The number of bytes that can be uploaded to the account
#    in the current month.  For new notes that are created, this is the length
#    of the note content (in Unicode characters) plus the size of each resource
#    (in bytes).  For edited notes, this is the the difference between the old
#    length and the new length (if this is greater than 0) plus the size of
#    each new resource.
#    </dd>
#  <dt>userNoteCountMax</dt>
#    <dd>Maximum number of Notes per user</dd>
#  <dt>userNotebookCountMax</dt>
#    <dd>Maximum number of Notebooks per user</dd>
#  <dt>userTagCountMax</dt>
#    <dd>Maximum number of Tags per account</dd>
#  <dt>noteTagCountMax</dt>
#    <dd>Maximum number of Tags per Note</dd>
#  <dt>userSavedSearchesMax</d>
#    <dd>Maximum number of SavedSearches per account</dd>
#  <dt>noteResourceCountMax</dt>
#    <dd>The maximum number of Resources per Note</dd>
#  </dl>
      class AccountLimits
        include ::Thrift::Struct, ::Thrift::Struct_Union
        USERMAILLIMITDAILY = 1
        NOTESIZEMAX = 2
        RESOURCESIZEMAX = 3
        USERLINKEDNOTEBOOKMAX = 4
        UPLOADLIMIT = 5
        USERNOTECOUNTMAX = 6
        USERNOTEBOOKCOUNTMAX = 7
        USERTAGCOUNTMAX = 8
        NOTETAGCOUNTMAX = 9
        USERSAVEDSEARCHESMAX = 10
        NOTERESOURCECOUNTMAX = 11

        FIELDS = {
          USERMAILLIMITDAILY => {:type => ::Thrift::Types::I32, :name => 'userMailLimitDaily', :optional => true},
          NOTESIZEMAX => {:type => ::Thrift::Types::I64, :name => 'noteSizeMax', :optional => true},
          RESOURCESIZEMAX => {:type => ::Thrift::Types::I64, :name => 'resourceSizeMax', :optional => true},
          USERLINKEDNOTEBOOKMAX => {:type => ::Thrift::Types::I32, :name => 'userLinkedNotebookMax', :optional => true},
          UPLOADLIMIT => {:type => ::Thrift::Types::I64, :name => 'uploadLimit', :optional => true},
          USERNOTECOUNTMAX => {:type => ::Thrift::Types::I32, :name => 'userNoteCountMax', :optional => true},
          USERNOTEBOOKCOUNTMAX => {:type => ::Thrift::Types::I32, :name => 'userNotebookCountMax', :optional => true},
          USERTAGCOUNTMAX => {:type => ::Thrift::Types::I32, :name => 'userTagCountMax', :optional => true},
          NOTETAGCOUNTMAX => {:type => ::Thrift::Types::I32, :name => 'noteTagCountMax', :optional => true},
          USERSAVEDSEARCHESMAX => {:type => ::Thrift::Types::I32, :name => 'userSavedSearchesMax', :optional => true},
          NOTERESOURCECOUNTMAX => {:type => ::Thrift::Types::I32, :name => 'noteResourceCountMax', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      #  This structure is used to provide information about a user's Premium account.
# <dl>
#  <dt>currentTime</dt>
#    <dd>
#    The server-side date and time when this data was generated.
#    </dd>
#  <dt>premium</dt>
#    <dd>
#    True if the user's account is Premium.
#    </dd>
#  <dt>premiumRecurring</dt>
#    <dd>
#    True if the user's account is Premium and has a recurring payment method.
#    </dd>
#  <dt>premiumExpirationDate</dt>
#    <dd>
#    The date when the user's Premium account expires, or the date when the
#    user's account is due for payment if it has a recurring payment method.
#    </dd>
#  <dt>premiumExtendable</dt>
#    <dd>
#    True if the user is eligible for purchasing Premium account extensions.
#    </dd>
#  <dt>premiumPending</dt>
#    <dd>
#    True if the user's Premium account is pending payment confirmation
#    </dd>
#  <dt>premiumCancellationPending</dt>
#    <dd>
#    True if the user has requested that no further charges to be made; the
#    Premium account will remain active until it expires.
#    </dd>
#  <dt>canPurchaseUploadAllowance</dt>
#    <dd>
#    True if the user is eligible for purchasing additional upload allowance.
#    </dd>
#  <dt>premiumUpgradable</dt>
#    <dd>
#    True if the user is eligible for purchasing Premium account upgrade.
#    </dd>
#  </dl>
      class PremiumInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CURRENTTIME = 1
        PREMIUM = 2
        PREMIUMRECURRING = 3
        PREMIUMEXPIRATIONDATE = 4
        PREMIUMEXTENDABLE = 5
        PREMIUMPENDING = 6
        PREMIUMCANCELLATIONPENDING = 7
        CANPURCHASEUPLOADALLOWANCE = 8
        PREMIUMUPGRADABLE = 11

        FIELDS = {
          CURRENTTIME => {:type => ::Thrift::Types::I64, :name => 'currentTime'},
          PREMIUM => {:type => ::Thrift::Types::BOOL, :name => 'premium'},
          PREMIUMRECURRING => {:type => ::Thrift::Types::BOOL, :name => 'premiumRecurring'},
          PREMIUMEXPIRATIONDATE => {:type => ::Thrift::Types::I64, :name => 'premiumExpirationDate', :optional => true},
          PREMIUMEXTENDABLE => {:type => ::Thrift::Types::BOOL, :name => 'premiumExtendable'},
          PREMIUMPENDING => {:type => ::Thrift::Types::BOOL, :name => 'premiumPending'},
          PREMIUMCANCELLATIONPENDING => {:type => ::Thrift::Types::BOOL, :name => 'premiumCancellationPending'},
          CANPURCHASEUPLOADALLOWANCE => {:type => ::Thrift::Types::BOOL, :name => 'canPurchaseUploadAllowance'},
          PREMIUMUPGRADABLE => {:type => ::Thrift::Types::BOOL, :name => 'premiumUpgradable', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field currentTime is unset!') unless @currentTime
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field premium is unset!') if @premium.nil?
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field premiumRecurring is unset!') if @premiumRecurring.nil?
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field premiumExtendable is unset!') if @premiumExtendable.nil?
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field premiumPending is unset!') if @premiumPending.nil?
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field premiumCancellationPending is unset!') if @premiumCancellationPending.nil?
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field canPurchaseUploadAllowance is unset!') if @canPurchaseUploadAllowance.nil?
        end

        ::Thrift::Struct.generate_accessors self
      end

      #  This structure is used to provide information about a user's current
#  subscription.
# 
# <dl>
#  <dt>currentTime</dt>
#    <dd>
#    The server-side date and time when this data was generated.
#    </dd>
#  <dt>currentlySubscribed</dt>
#    <dd>
#    True if the user has a non-Basic Evernote subscription.
#    </dd>
#  <dt>subscriptionRecurring</dt>
#    <dd>
#    True if the user has a subscription paid for with a recurring payment method.
#    </dd>
#  <dt>subscriptionExpirationDate</dt>
#    <dd>
#    The date when the user's subscription expires, or the date when the
#    user's account is due for payment if it has a recurring payment method.
#    </dd>
#  <dt>subscriptionPending</dt>
#    <dd>
#    True if the user's subscription is pending payment confirmation
#    </dd>
#  <dt>subscriptionCancellationPending</dt>
#    <dd>
#    True if the user has requested that no further charges to be made; the
#    subscription will remain active until it expires.
#    </dd>
#  <dt>serviceLevelsEligibleForPurchase</dt>
#    <dd>
#    The set of ServiceLevels the user is eligible to purchase.
#    </dd>
#  <dt>currentSku</dt>
#    <dd>
#    The SKU code for a user's current subscription, if the user is currently
#    subscribed.
#    </dd>
#  <dt>validUntil</dt>
#    <dd>
#    The next time this set of information is expected to change.
#    </dd>
#  </dl>
      class SubscriptionInfo
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CURRENTTIME = 1
        CURRENTLYSUBSCRIBED = 2
        SUBSCRIPTIONRECURRING = 3
        SUBSCRIPTIONEXPIRATIONDATE = 4
        SUBSCRIPTIONPENDING = 5
        SUBSCRIPTIONCANCELLATIONPENDING = 6
        SERVICELEVELSELIGIBLEFORPURCHASE = 7
        CURRENTSKU = 8
        VALIDUNTIL = 9

        FIELDS = {
          CURRENTTIME => {:type => ::Thrift::Types::I64, :name => 'currentTime'},
          CURRENTLYSUBSCRIBED => {:type => ::Thrift::Types::BOOL, :name => 'currentlySubscribed'},
          SUBSCRIPTIONRECURRING => {:type => ::Thrift::Types::BOOL, :name => 'subscriptionRecurring'},
          SUBSCRIPTIONEXPIRATIONDATE => {:type => ::Thrift::Types::I64, :name => 'subscriptionExpirationDate', :optional => true},
          SUBSCRIPTIONPENDING => {:type => ::Thrift::Types::BOOL, :name => 'subscriptionPending'},
          SUBSCRIPTIONCANCELLATIONPENDING => {:type => ::Thrift::Types::BOOL, :name => 'subscriptionCancellationPending'},
          SERVICELEVELSELIGIBLEFORPURCHASE => {:type => ::Thrift::Types::SET, :name => 'serviceLevelsEligibleForPurchase', :element => {:type => ::Thrift::Types::I32, :enum_class => ::Evernote::EDAM::Type::ServiceLevel}},
          CURRENTSKU => {:type => ::Thrift::Types::STRING, :name => 'currentSku', :optional => true},
          VALIDUNTIL => {:type => ::Thrift::Types::I64, :name => 'validUntil', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field currentTime is unset!') unless @currentTime
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field currentlySubscribed is unset!') if @currentlySubscribed.nil?
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field subscriptionRecurring is unset!') if @subscriptionRecurring.nil?
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field subscriptionPending is unset!') if @subscriptionPending.nil?
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field subscriptionCancellationPending is unset!') if @subscriptionCancellationPending.nil?
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field serviceLevelsEligibleForPurchase is unset!') unless @serviceLevelsEligibleForPurchase
        end

        ::Thrift::Struct.generate_accessors self
      end

      #  This represents the information about a single user account.
# <dl>
#  <dt>id</dt>
#    <dd>The unique numeric identifier for the account, which will not
#    change for the lifetime of the account.
#    </dd>
# 
#  <dt>username</dt>
#    <dd>The name that uniquely identifies a single user account. This name
#    may be presented by the user, along with their password, to log into
#    their account.
#    May only contain a-z, 0-9, or '-', and may not start or end with the '-'
#    <br/>
#    Length:  EDAM_USER_USERNAME_LEN_MIN - EDAM_USER_USERNAME_LEN_MAX
#    <br/>
#    Regex:  EDAM_USER_USERNAME_REGEX
#    </dd>
# 
#  <dt>email</dt>
#    <dd>The email address registered for the user.  Must comply with
#    RFC 2821 and RFC 2822.<br/>
#    Third party applications that authenticate using OAuth do not have
#    access to this field.
#    Length:  EDAM_EMAIL_LEN_MIN - EDAM_EMAIL_LEN_MAX
#    <br/>
#    Regex:  EDAM_EMAIL_REGEX
#    </dd>
# 
#  <dt>name</dt>
#    <dd>The printable name of the user, which may be a combination
#    of given and family names.  This is used instead of separate "first"
#    and "last" names due to variations in international name format/order.
#    May not start or end with a whitespace character.  May contain any
#    character but carriage return or newline (Unicode classes Zl and Zp).
#    <br/>
#    Length:  EDAM_USER_NAME_LEN_MIN - EDAM_USER_NAME_LEN_MAX
#    <br/>
#    Regex:  EDAM_USER_NAME_REGEX
#    </dd>
# 
#  <dt>timezone</dt>
#    <dd>The zone ID for the user's default location.  If present,
#    this may be used to localize the display of any timestamp for which no
#    other timezone is available.
#    The format must be encoded as a standard zone ID such as
#    "America/Los_Angeles" or "GMT+08:00"
#    <br/>
#    Length:  EDAM_TIMEZONE_LEN_MIN - EDAM_TIMEZONE_LEN_MAX
#    <br/>
#    Regex:  EDAM_TIMEZONE_REGEX
#    </dd>
# 
#  <dt>serviceLevel</dt>
#    <dd>The level of service the user currently receives. This will always be populated
#        for users retrieved from the Evernote service.
#    </dd>
# 
#  <dt>created</dt>
#    <dd>The date and time when this user account was created in the
#    service.
#    </dd>
# 
#  <dt>updated</dt>
#    <dd>The date and time when this user account was last modified
#    in the service.
#    </dd>
# 
#  <dt>deleted</dt>
#    <dd>If the account has been deleted from the system (e.g. as
#    the result of a legal request by the user), the date and time of the
#    deletion will be represented here.  If not, this value will not be set.
#    </dd>
# 
#  <dt>active</dt>
#    <dd>If the user account is available for login and
#    synchronization, this flag will be set to true.
#    </dd>
# 
#  <dt>shardId</dt>
#    <dd>DEPRECATED - Client applications should have no need to use this field.
#    </dd>
# 
#  <dt>attributes</dt>
#    <dd>If present, this will contain a list of the attributes
#    for this user account.
#    </dd>
# 
#  <dt>accounting</dt>
#    <dd>Bookkeeping information for the user's subscription.
#    </dd>
# 
#  <dt>premiumInfo</dt>
#    <dd>If present, this will contain a set of commerce information
#    relating to the user's premium service level.
#    </dd>
# 
#  <dt>businessUserInfo</dt>
#    <dd>If present, this will contain a set of business information
#    relating to the user's business membership.  If not present, the
#    user is not currently part of a business.
#    </dd>
# 
#  <dt>photoUrl</dt>
#    <dd>The URL of the photo that represents this User. This field is filled in by the
#    service and is read-only to clients. If <code>photoLastUpdated</code> is
#    not set, this url will point to a placeholder user photo generated by the
#    service.</dd>
# 
#  <dt>photoLastUpdated</dt>
#    <dd>The time at which the photo at 'photoUrl' was last updated by this User. This
#    field will be null if the User never set a profile photo. This field is filled in by
#    the service and is read-only to clients.</dd>
# 
#  <dt>accountLimits</dt>
#    <dd>Account limits applicable for this user.</dd>
# 
#  <dt>subscriptionInfo</dt>
#    <dd>If present, this will contain a set of commerce information relating
#    to the user's account and, if the user has non-free subscription,
#    information relating to that subscription.
#    </dd>
# 
#  </dl>
      class User
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ID = 1
        USERNAME = 2
        EMAIL = 3
        NAME = 4
        TIMEZONE = 6
        PRIVILEGE = 7
        SERVICELEVEL = 21
        CREATED = 9
        UPDATED = 10
        DELETED = 11
        ACTIVE = 13
        SHARDID = 14
        ATTRIBUTES = 15
        ACCOUNTING = 16
        BUSINESSUSERINFO = 18
        PHOTOURL = 19
        PHOTOLASTUPDATED = 20
        ACCOUNTLIMITS = 22
        SUBSCRIPTIONINFO = 23

        FIELDS = {
          ID => {:type => ::Thrift::Types::I32, :name => 'id', :optional => true},
          USERNAME => {:type => ::Thrift::Types::STRING, :name => 'username', :optional => true},
          EMAIL => {:type => ::Thrift::Types::STRING, :name => 'email', :optional => true},
          NAME => {:type => ::Thrift::Types::STRING, :name => 'name', :optional => true},
          TIMEZONE => {:type => ::Thrift::Types::STRING, :name => 'timezone', :optional => true},
          PRIVILEGE => {:type => ::Thrift::Types::I32, :name => 'privilege', :optional => true, :enum_class => ::Evernote::EDAM::Type::PrivilegeLevel},
          SERVICELEVEL => {:type => ::Thrift::Types::I32, :name => 'serviceLevel', :optional => true, :enum_class => ::Evernote::EDAM::Type::ServiceLevel},
          CREATED => {:type => ::Thrift::Types::I64, :name => 'created', :optional => true},
          UPDATED => {:type => ::Thrift::Types::I64, :name => 'updated', :optional => true},
          DELETED => {:type => ::Thrift::Types::I64, :name => 'deleted', :optional => true},
          ACTIVE => {:type => ::Thrift::Types::BOOL, :name => 'active', :optional => true},
          SHARDID => {:type => ::Thrift::Types::STRING, :name => 'shardId', :optional => true},
          ATTRIBUTES => {:type => ::Thrift::Types::STRUCT, :name => 'attributes', :class => ::Evernote::EDAM::Type::UserAttributes, :optional => true},
          ACCOUNTING => {:type => ::Thrift::Types::STRUCT, :name => 'accounting', :class => ::Evernote::EDAM::Type::Accounting, :optional => true},
          BUSINESSUSERINFO => {:type => ::Thrift::Types::STRUCT, :name => 'businessUserInfo', :class => ::Evernote::EDAM::Type::BusinessUserInfo, :optional => true},
          PHOTOURL => {:type => ::Thrift::Types::STRING, :name => 'photoUrl', :optional => true},
          PHOTOLASTUPDATED => {:type => ::Thrift::Types::I64, :name => 'photoLastUpdated', :optional => true},
          ACCOUNTLIMITS => {:type => ::Thrift::Types::STRUCT, :name => 'accountLimits', :class => ::Evernote::EDAM::Type::AccountLimits, :optional => true},
          SUBSCRIPTIONINFO => {:type => ::Thrift::Types::STRUCT, :name => 'subscriptionInfo', :class => ::Evernote::EDAM::Type::SubscriptionInfo, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @privilege.nil? || ::Evernote::EDAM::Type::PrivilegeLevel::VALID_VALUES.include?(@privilege)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field privilege!')
          end
          unless @serviceLevel.nil? || ::Evernote::EDAM::Type::ServiceLevel::VALID_VALUES.include?(@serviceLevel)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field serviceLevel!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A structure that represents contact information. Note this does not necessarily correspond to
# an Evernote user.
# 
# <dl>
# <dt>name</dt>
# <dd>The displayable name of this contact. This field is filled in by the service and
#     is read-only to clients.
# </dd>
# <dt>id</dt>
# <dd>A unique identifier for this ContactType.
# </dd>
# <dt>type</dt>
# <dd>What service does this contact come from?
# </dd>
# <dt>photoUrl</dt>
# <dd>A URL of a profile photo representing this Contact. This field is filled in by the
#     service and is read-only to clients.
# </dd>
# <dt>photoLastUpdated</dt>
# <dd>timestamp when the profile photo at 'photoUrl' was last updated.
#     This field will be null if the user has never set a profile photo.
#     This field is filled in by the service and is read-only to clients.
# </dd>
# <dt>messagingPermit</dt>
# <dd>This field will only be filled by the service when it is giving a Contact record
#     to a client, and that client does not normally have enough permission to send a
#     new message to the person represented through this Contact. In that case, this
#     whole Contact record could be used to send a new Message to the Contact, and the
#     service will inspect this permit to confirm that operation was allowed.
# </dd>
# <dt>messagingPermitExpires</dt>
# <dd>If this field is set, then this (whole) Contact record may be used in calls to
#     sendMessage until this time. After that time, those calls may be rejected by the
#     service if the caller does not have direct permission to initiate a message with
#     the represented Evernote user.
# </dd>
# </dl>
      class Contact
        include ::Thrift::Struct, ::Thrift::Struct_Union
        NAME = 1
        ID = 2
        TYPE = 3
        PHOTOURL = 4
        PHOTOLASTUPDATED = 5
        MESSAGINGPERMIT = 6
        MESSAGINGPERMITEXPIRES = 7

        FIELDS = {
          NAME => {:type => ::Thrift::Types::STRING, :name => 'name', :optional => true},
          ID => {:type => ::Thrift::Types::STRING, :name => 'id', :optional => true},
          TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :optional => true, :enum_class => ::Evernote::EDAM::Type::ContactType},
          PHOTOURL => {:type => ::Thrift::Types::STRING, :name => 'photoUrl', :optional => true},
          PHOTOLASTUPDATED => {:type => ::Thrift::Types::I64, :name => 'photoLastUpdated', :optional => true},
          MESSAGINGPERMIT => {:type => ::Thrift::Types::STRING, :name => 'messagingPermit', :binary => true, :optional => true},
          MESSAGINGPERMITEXPIRES => {:type => ::Thrift::Types::I64, :name => 'messagingPermitExpires', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @type.nil? || ::Evernote::EDAM::Type::ContactType::VALID_VALUES.include?(@type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # An object that represents the relationship between a Contact that possibly
# belongs to an Evernote User.
# 
# <dl>
#  <dt>id</dt>
#  <dd>The unique identifier for this mapping.
#  </dd>
# 
#  <dt>contact<dt>
#  <dd>The Contact that can be used to address this Identity. May be unset.
#  </dd>
# 
#  <dt>userId</dt>
#  <dd>The Evernote User id that is connected to the Contact. May be unset
#      if this identity has not yet been claimed, or the caller is not
#      connected to this identity.
#  </dd>
# 
#  <dt>deactivated</dt>
#  <dd>Indicates that the contact for this identity is no longer active and
#  should not be used when creating new threads using Destination.recipients,
#  unless you know of another Identity instance with the same contact information
#  that is active.  If you are connected to the user (see userConnected), you
#  can still create threads using their Evernote-type contact.</dd>
# 
#  <dt>sameBusiness</dt>
#  <dd>Does this Identity belong to someone who is in the same business as the
#      caller?
#  </dd>
# 
#  <dt>blocked</dt>
#  <dd>Has the caller blocked the Evernote user this Identity represents?
#  </dd>
# 
#  <dt>userConnected</dt>
#  <dd>Indicates that the caller is "connected" to the user of this
#  identity via this identity.  When you have a connection via an
#  identity, you should always create new threads using the
#  Evernote-type contact (see ContactType) using the userId field
#  from a connected Identity.  On the Evernote service, the
#  Evernote-type contact is the most durable. Phone numbers and
#  e-mail addresses can get re-assigned but your Evernote account
#  user ID will remain the same.  A connection exists when both of
#  you are in the same business or the user has replied to a thread
#  that you are on.  When connected, you will also get to see more
#  information about the user who has claimed the identity.  Note
#  that you are never connected to yourself since you won't be
#  sending messages to yourself, but you will obviously see your own
#  profile information.
#  </dd>
# 
#  <dt>eventId</dt>
#  <dd>A server-assigned sequence number for the events in the messages
#  subsystem.
#  </dd>
# </dl>
      class Identity
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ID = 1
        CONTACT = 2
        USERID = 3
        DEACTIVATED = 4
        SAMEBUSINESS = 5
        BLOCKED = 6
        USERCONNECTED = 7
        EVENTID = 8

        FIELDS = {
          ID => {:type => ::Thrift::Types::I64, :name => 'id'},
          CONTACT => {:type => ::Thrift::Types::STRUCT, :name => 'contact', :class => ::Evernote::EDAM::Type::Contact, :optional => true},
          USERID => {:type => ::Thrift::Types::I32, :name => 'userId', :optional => true},
          DEACTIVATED => {:type => ::Thrift::Types::BOOL, :name => 'deactivated', :optional => true},
          SAMEBUSINESS => {:type => ::Thrift::Types::BOOL, :name => 'sameBusiness', :optional => true},
          BLOCKED => {:type => ::Thrift::Types::BOOL, :name => 'blocked', :optional => true},
          USERCONNECTED => {:type => ::Thrift::Types::BOOL, :name => 'userConnected', :optional => true},
          EVENTID => {:type => ::Thrift::Types::I64, :name => 'eventId', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
        end

        ::Thrift::Struct.generate_accessors self
      end

      #  A tag within a user's account is a unique name which may be organized
#  a simple hierarchy.
# <dl>
#  <dt>guid</dt>
#    <dd>The unique identifier of this tag. Will be set by the service,
#    so may be omitted by the client when creating the Tag.
#    <br/>
#    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
#    <br/>
#    Regex:  EDAM_GUID_REGEX
#    </dd>
# 
#  <dt>name</dt>
#    <dd>A sequence of characters representing the tag's identifier.
#    Case is preserved, but is ignored for comparisons.
#    This means that an account may only have one tag with a given name, via
#    case-insensitive comparison, so an account may not have both "food" and
#    "Food" tags.
#    May not contain a comma (','), and may not begin or end with a space.
#    <br/>
#    Length:  EDAM_TAG_NAME_LEN_MIN - EDAM_TAG_NAME_LEN_MAX
#    <br/>
#    Regex:  EDAM_TAG_NAME_REGEX
#    </dd>
# 
#  <dt>parentGuid</dt>
#    <dd>If this is set, then this is the GUID of the tag that
#    holds this tag within the tag organizational hierarchy.  If this is
#    not set, then the tag has no parent and it is a "top level" tag.
#    Cycles are not allowed (e.g. a->parent->parent == a) and will be
#    rejected by the service.
#    <br/>
#    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
#    <br/>
#    Regex:  EDAM_GUID_REGEX
#    </dd>
# 
#  <dt>updateSequenceNum</dt>
#    <dd>A number identifying the last transaction to
#    modify the state of this object.  The USN values are sequential within an
#    account, and can be used to compare the order of modifications within the
#    service.
#    </dd>
#  </dl>
      class Tag
        include ::Thrift::Struct, ::Thrift::Struct_Union
        GUID = 1
        NAME = 2
        PARENTGUID = 3
        UPDATESEQUENCENUM = 4

        FIELDS = {
          GUID => {:type => ::Thrift::Types::STRING, :name => 'guid', :optional => true},
          NAME => {:type => ::Thrift::Types::STRING, :name => 'name', :optional => true},
          PARENTGUID => {:type => ::Thrift::Types::STRING, :name => 'parentGuid', :optional => true},
          UPDATESEQUENCENUM => {:type => ::Thrift::Types::I32, :name => 'updateSequenceNum', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A structure that wraps a map of name/value pairs whose values are not
# always present in the structure in order to reduce space when obtaining
# batches of entities that contain the map.
# 
# When the server provides the client with a LazyMap, it will fill in either
# the keysOnly field or the fullMap field, but never both, based on the API
# and parameters.
# 
# When a client provides a LazyMap to the server as part of an update to
# an object, the server will only update the LazyMap if the fullMap field is
# set. If the fullMap field is not set, the server will not make any changes
# to the map.
# 
# Check the API documentation of the individual calls involving the LazyMap
# for full details including the constraints of the names and values of the
# map.
# 
# <dl>
# <dt>keysOnly</dt>
#   <dd>The set of keys for the map.  This field is ignored by the
#       server when set.
#   </dd>
# 
# <dt>fullMap</dt>
#   <dd>The complete map, including all keys and values.
#   </dd>
# </dl>
      class LazyMap
        include ::Thrift::Struct, ::Thrift::Struct_Union
        KEYSONLY = 1
        FULLMAP = 2

        FIELDS = {
          KEYSONLY => {:type => ::Thrift::Types::SET, :name => 'keysOnly', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          FULLMAP => {:type => ::Thrift::Types::MAP, :name => 'fullMap', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Structure holding the optional attributes of a Resource
# <dl>
# <dt>sourceURL</dt>
#   <dd>the original location where the resource was hosted
#   <br/>
#    Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#   </dd>
# 
# <dt>timestamp</dt>
#   <dd>the date and time that is associated with this resource
#   (e.g. the time embedded in an image from a digital camera with a clock)
#   </dd>
# 
# <dt>latitude</dt>
#   <dd>the latitude where the resource was captured
#   </dd>
# 
# <dt>longitude</dt>
#   <dd>the longitude where the resource was captured
#   </dd>
# 
# <dt>altitude</dt>
#   <dd>the altitude where the resource was captured
#   </dd>
# 
# <dt>cameraMake</dt>
#   <dd>information about an image's camera, e.g. as embedded in
#   the image's EXIF data
#   <br/>
#   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#   </dd>
# 
# <dt>cameraModel</dt>
#   <dd>information about an image's camera, e.g. as embedded
#   in the image's EXIF data
#   <br/>
#   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#   </dd>
# 
# <dt>clientWillIndex</dt>
#   <dd>if true, then the original client that submitted
#   the resource plans to submit the recognition index for this resource at a
#   later time.
#   </dd>
# 
# <dt>recoType</dt>
#   <dd>DEPRECATED - this field is no longer set by the service, so should
#     be ignored.
#   </dd>
# 
# <dt>fileName</dt>
#   <dd>if the resource came from a source that provided an
#   explicit file name, the original name will be stored here.  Many resources
#   come from unnamed sources, so this will not always be set.
#   </dd>
# 
# <dt>attachment</dt>
#   <dd>this will be true if the resource should be displayed as an attachment,
#   or false if the resource should be displayed inline (if possible).
#   </dd>
# 
# <dt>applicationData</dt>
# <dd>Provides a location for applications to store a relatively small
# (4kb) blob of data associated with a Resource that is not visible to the user
# and that is opaque to the Evernote service. A single application may use at most
# one entry in this map, using its API consumer key as the map key. See the
# documentation for LazyMap for a description of when the actual map values
# are returned by the service.
# <p>To safely add or modify your application's entry in the map, use
# NoteStore.setResourceApplicationDataEntry. To safely remove your application's
# entry from the map, use NoteStore.unsetResourceApplicationDataEntry.</p>
# Minimum length of a name (key): EDAM_APPLICATIONDATA_NAME_LEN_MIN
# <br/>
# Sum max size of key and value: EDAM_APPLICATIONDATA_ENTRY_LEN_MAX
# <br/>
# Syntax regex for name (key): EDAM_APPLICATIONDATA_NAME_REGEX
# </dd>
# 
# </dl>
      class ResourceAttributes
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SOURCEURL = 1
        TIMESTAMP = 2
        LATITUDE = 3
        LONGITUDE = 4
        ALTITUDE = 5
        CAMERAMAKE = 6
        CAMERAMODEL = 7
        CLIENTWILLINDEX = 8
        RECOTYPE = 9
        FILENAME = 10
        ATTACHMENT = 11
        APPLICATIONDATA = 12

        FIELDS = {
          SOURCEURL => {:type => ::Thrift::Types::STRING, :name => 'sourceURL', :optional => true},
          TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp', :optional => true},
          LATITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'latitude', :optional => true},
          LONGITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'longitude', :optional => true},
          ALTITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'altitude', :optional => true},
          CAMERAMAKE => {:type => ::Thrift::Types::STRING, :name => 'cameraMake', :optional => true},
          CAMERAMODEL => {:type => ::Thrift::Types::STRING, :name => 'cameraModel', :optional => true},
          CLIENTWILLINDEX => {:type => ::Thrift::Types::BOOL, :name => 'clientWillIndex', :optional => true},
          RECOTYPE => {:type => ::Thrift::Types::STRING, :name => 'recoType', :optional => true},
          FILENAME => {:type => ::Thrift::Types::STRING, :name => 'fileName', :optional => true},
          ATTACHMENT => {:type => ::Thrift::Types::BOOL, :name => 'attachment', :optional => true},
          APPLICATIONDATA => {:type => ::Thrift::Types::STRUCT, :name => 'applicationData', :class => ::Evernote::EDAM::Type::LazyMap, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Every media file that is embedded or attached to a note is represented
# through a Resource entry.
# <dl>
# <dt>guid</dt>
#   <dd>The unique identifier of this resource.  Will be set whenever
#   a resource is retrieved from the service, but may be null when a client
#   is creating a resource.
#   <br/>
#   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
#   <br/>
#   Regex:  EDAM_GUID_REGEX
#   </dd>
# 
# <dt>noteGuid</dt>
#   <dd>The unique identifier of the Note that holds this
#   Resource. Will be set whenever the resource is retrieved from the service,
#   but may be null when a client is creating a resource.
#   <br/>
#   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
#   <br/>
#   Regex:  EDAM_GUID_REGEX
#   </dd>
# 
# <dt>data</dt>
#   <dd>The contents of the resource.
#   Maximum length:  The data.body is limited to EDAM_RESOURCE_SIZE_MAX_FREE
#   for free accounts and EDAM_RESOURCE_SIZE_MAX_PREMIUM for premium accounts.
#   </dd>
# 
# <dt>mime</dt>
#   <dd>The MIME type for the embedded resource.  E.g. "image/gif"
#   <br/>
#   Length:  EDAM_MIME_LEN_MIN - EDAM_MIME_LEN_MAX
#   <br/>
#   Regex:  EDAM_MIME_REGEX
#   </dd>
# 
# <dt>width</dt>
#   <dd>If set, this contains the display width of this resource, in
#   pixels.
#   </dd>
# 
# <dt>height</dt>
#   <dd>If set, this contains the display height of this resource,
#   in pixels.
#   </dd>
# 
# <dt>duration</dt>
#   <dd>DEPRECATED: ignored.
#   </dd>
# 
# <dt>active</dt>
#   <dd>DEPRECATED: ignored.
#   </dd>
# 
# <dt>recognition</dt>
#   <dd>If set, this will hold the encoded data that provides
#   information on search and recognition within this resource.
#   </dd>
# 
# <dt>attributes</dt>
#   <dd>A list of the attributes for this resource.
#   </dd>
# 
# <dt>updateSequenceNum</dt>
#   <dd>A number identifying the last transaction to
#   modify the state of this object. The USN values are sequential within an
#   account, and can be used to compare the order of modifications within the
#   service.
#   </dd>
# 
# <dt>alternateData</dt>
#   <dd>Some Resources may be assigned an alternate data format by the service
#   which may be more appropriate for indexing or rendering than the original
#   data provided by the user.  In these cases, the alternate data form will
#   be available via this Data element.  If a Resource has no alternate form,
#   this field will be unset.</dd>
# </dl>
      class Resource
        include ::Thrift::Struct, ::Thrift::Struct_Union
        GUID = 1
        NOTEGUID = 2
        DATA = 3
        MIME = 4
        WIDTH = 5
        HEIGHT = 6
        DURATION = 7
        ACTIVE = 8
        RECOGNITION = 9
        ATTRIBUTES = 11
        UPDATESEQUENCENUM = 12
        ALTERNATEDATA = 13

        FIELDS = {
          GUID => {:type => ::Thrift::Types::STRING, :name => 'guid', :optional => true},
          NOTEGUID => {:type => ::Thrift::Types::STRING, :name => 'noteGuid', :optional => true},
          DATA => {:type => ::Thrift::Types::STRUCT, :name => 'data', :class => ::Evernote::EDAM::Type::Data, :optional => true},
          MIME => {:type => ::Thrift::Types::STRING, :name => 'mime', :optional => true},
          WIDTH => {:type => ::Thrift::Types::I16, :name => 'width', :optional => true},
          HEIGHT => {:type => ::Thrift::Types::I16, :name => 'height', :optional => true},
          DURATION => {:type => ::Thrift::Types::I16, :name => 'duration', :optional => true},
          ACTIVE => {:type => ::Thrift::Types::BOOL, :name => 'active', :optional => true},
          RECOGNITION => {:type => ::Thrift::Types::STRUCT, :name => 'recognition', :class => ::Evernote::EDAM::Type::Data, :optional => true},
          ATTRIBUTES => {:type => ::Thrift::Types::STRUCT, :name => 'attributes', :class => ::Evernote::EDAM::Type::ResourceAttributes, :optional => true},
          UPDATESEQUENCENUM => {:type => ::Thrift::Types::I32, :name => 'updateSequenceNum', :optional => true},
          ALTERNATEDATA => {:type => ::Thrift::Types::STRUCT, :name => 'alternateData', :class => ::Evernote::EDAM::Type::Data, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The list of optional attributes that can be stored on a note.
# <dl>
# <dt>subjectDate</dt>
#   <dd>time that the note refers to
#   </dd>
# 
# <dt>latitude</dt>
#   <dd>the latitude where the note was taken
#   </dd>
# 
# <dt>longitude</dt>
#   <dd>the longitude where the note was taken
#   </dd>
# 
# <dt>altitude</dt>
#   <dd>the altitude where the note was taken
#   </dd>
# 
# <dt>author</dt>
#   <dd>the author of the content of the note
#   <br/>
#   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#   </dd>
# 
# <dt>source</dt>
#   <dd>the method that the note was added to the account, if the
#   note wasn't directly authored in an Evernote desktop client.
#   <br/>
#   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#   </dd>
# 
# <dt>sourceURL</dt>
#   <dd>the original location where the resource was hosted. For web clips,
#   this will be the URL of the page that was clipped.
#   <br/>
#   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#   </dd>
# 
# <dt>sourceApplication</dt>
#   <dd>an identifying string for the application that
#   created this note.  This string does not have a guaranteed syntax or
#   structure -- it is intended for human inspection and tracking.
#   <br/>
#   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
#   </dd>
# 
# <dt>shareDate</dt>
#  <dd>The date and time when this note was directly shared via its own URL.
#  This is only set on notes that were individually shared - it is independent
#  of any notebook-level sharing of the containing notebook. This field
#  is treated as "read-only" for clients; the server will ignore changes
#  to this field from an external client.
#  </dd>
# 
# <dt>reminderOrder</dt>
# <dd>The set of notes with this parameter set are considered
# "reminders" and are to be treated specially by clients to give them
# higher UI prominence within a notebook.  The value is used to sort
# the reminder notes within the notebook with higher values
# representing greater prominence.  Outside of the context of a
# notebook, the value of this parameter is undefined.  The value is
# not intended to be compared to the values of reminder notes in
# other notebooks.  In order to allow clients to place a note at a
# higher precedence than other notes, you should never set a value
# greater than the current time (as defined for a Timetstamp). To
# place a note at higher precedence than existing notes, set the
# value to the current time as defined for a timestamp (milliseconds
# since the epoch).  Synchronizing clients must remember the time when
# the update was performed, using the local clock on the client,
# and use that value when they later upload the note to the service.
# Clients must not set the reminderOrder to the reminderTime as the
# reminderTime could be in the future.  Those two fields are never
# intended to be related.  The correct value for reminderOrder field
# for new notes is the "current" time when the user indicated that
# the note is a reminder.  Clients may implement a separate
# "sort by date" feature to show notes ordered by reminderTime.
# Whenever a reminderDoneTime or reminderTime is set but a
# reminderOrder is not set, the server will fill in the current
# server time for the reminderOrder field.</dd>
# 
# <dt>reminderDoneTime</dt>
# <dd>The date and time when a user dismissed/"marked done" the reminder
# on the note.  Users typically do not manually set this value directly
# as it is set to the time when the user dismissed/"marked done" the
# reminder.</dd>
# 
# <dt>reminderTime</dt>
# <dd>The date and time a user has selected to be reminded of the note.
# A note with this value set is known as a "reminder" and the user can
# be reminded, via e-mail or client-specific notifications, of the note
# when the time is reached or about to be reached.  When a user sets
# a reminder time on a note that has a reminder done time, and that
# reminder time is in the future, then the reminder done time should be
# cleared.  This should happen regardless of any existing reminder time
# that may have previously existed on the note.</dd>
# 
# <dt>placeName</dt>
# <dd>Allows the user to assign a human-readable location name associated
# with a note. Users may assign values like 'Home' and 'Work'. Place
# names may also be populated with values from geonames database
# (e.g., a restaurant name). Applications are encouraged to normalize values
# so that grouping values by place name provides a useful result. Applications
# MUST NOT automatically add place name values based on geolocation without
# confirmation from the user; that is, the value in this field should be
# more useful than a simple automated lookup based on the note's latitude
# and longitude.</dd>
# 
# <dt>contentClass</dt>
# <dd>The class (or type) of note. This field is used to indicate to
# clients that special structured information is represented within
# the note such that special rules apply when making
# modifications. If contentClass is set and the client
# application does not specifically support the specified class,
# the client MUST treat the note as read-only. In this case, the
# client MAY modify the note's notebook and tags via the
# Note.notebookGuid and Note.tagGuids fields.  The client MAY also
# modify the reminderOrder field as well as the reminderTime and
# reminderDoneTime fields.
# <p>Applications should set contentClass only when they are creating notes
# that contain structured information that needs to be maintained in order
# for the user to be able to use the note within that application.
# Setting contentClass makes a note read-only in other applications, so
# there is a trade-off when an application chooses to use contentClass.
# Applications that set contentClass when creating notes must use a contentClass
# string of the form <i>CompanyName.ApplicationName</i> to ensure uniqueness.</p>
# Length restrictions: EDAM_NOTE_CONTENT_CLASS_LEN_MIN, EDAM_NOTE_CONTENT_CLASS_LEN_MAX
# <br/>
# Regex: EDAM_NOTE_CONTENT_CLASS_REGEX
# </dd>
# 
# <dt>applicationData</dt>
# <dd>Provides a location for applications to store a relatively small
# (4kb) blob of data that is not meant to be visible to the user and
# that is opaque to the Evernote service. A single application may use at most
# one entry in this map, using its API consumer key as the map key. See the
# documentation for LazyMap for a description of when the actual map values
# are returned by the service.
# <p>To safely add or modify your application's entry in the map, use
# NoteStore.setNoteApplicationDataEntry. To safely remove your application's
# entry from the map, use NoteStore.unsetNoteApplicationDataEntry.</p>
# Minimum length of a name (key): EDAM_APPLICATIONDATA_NAME_LEN_MIN
# <br/>
# Sum max size of key and value: EDAM_APPLICATIONDATA_ENTRY_LEN_MAX
# <br/>
# Syntax regex for name (key): EDAM_APPLICATIONDATA_NAME_REGEX
# </dd>
# 
# <dt>creatorId</dt>
# <dd>The numeric user ID of the user who originally created the note.</dd>
# 
# <dt>lastEditedBy</dt>
# <dd>An indication of who made the last change to the note.  If you are
# accessing the note via a shared notebook to which you have modification
# rights, or if you are the owner of the notebook to which the note belongs,
# then you have access to the value.  In this case, the value will be
# unset if the owner of the notebook containing the note was the last to
# make the modification, else it will be a string describing the
# guest who made the last edit.  If you do not have access to this value,
# it will be left unset.  This field is read-only by clients.  The server
# will ignore all values set by clients into this field.</dd>
# 
# <dt>lastEditorId</dt>
# <dd>The numeric user ID of the user described in lastEditedBy.</dd>
# 
# <dt>classifications</dt>
# <dd>A map of classifications applied to the note by clients or by the
# Evernote service. The key is the string name of the classification type,
# and the value is a constant that begins with CLASSIFICATION_.</dd>
# 
# <dt>sharedWithBusiness</dt>
# <dd>When this flag is set on a business note, any user in that business
# may view the note if they request it by GUID. This field is read-only by
# clients. The server will ignore all values set by clients into this field.
# 
# To share a note with the business, use NoteStore.shareNoteWithBusiness and
# to stop sharing a note with the business, use NoteStore.stopSharingNoteWithBusiness.
# </dd>
# 
# <dt>conflictSourceNoteGuid</dt>
# <dd>If set, this specifies the GUID of a note that caused a sync conflict
# resulting in the creation of a duplicate note. The duplicated note contains
# the user's changes that could not be applied as a result of the sync conflict,
# and uses the conflictSourceNoteGuid field to specify the note that caused the
# conflict. This allows clients to provide a customized user experience for note
# conflicts.
# </dd>
# 
# <dt>noteTitleQuality</dt>
# <dd>If set, this specifies that the note's title was automatically generated
# and indicates the likelihood that the generated title is useful for display to
# the user. If not set, the note's title was manually entered by the user.
# 
# Clients MUST set this attribute to one of the following values when the
# corresponding note's title was not manually entered by the user:
# EDAM_NOTE_TITLE_QUALITY_UNTITLED, EDAM_NOTE_TITLE_QUALITY_LOW,
# EDAM_NOTE_TITLE_QUALITY_MEDIUM or EDAM_NOTE_TITLE_QUALITY_HIGH.
# 
# When a user edits a note's title, clients MUST unset this value.
# </dd>
# </dl>
      class NoteAttributes
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUBJECTDATE = 1
        LATITUDE = 10
        LONGITUDE = 11
        ALTITUDE = 12
        AUTHOR = 13
        SOURCE = 14
        SOURCEURL = 15
        SOURCEAPPLICATION = 16
        SHAREDATE = 17
        REMINDERORDER = 18
        REMINDERDONETIME = 19
        REMINDERTIME = 20
        PLACENAME = 21
        CONTENTCLASS = 22
        APPLICATIONDATA = 23
        LASTEDITEDBY = 24
        CLASSIFICATIONS = 26
        CREATORID = 27
        LASTEDITORID = 28
        SHAREDWITHBUSINESS = 29
        CONFLICTSOURCENOTEGUID = 30
        NOTETITLEQUALITY = 31

        FIELDS = {
          SUBJECTDATE => {:type => ::Thrift::Types::I64, :name => 'subjectDate', :optional => true},
          LATITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'latitude', :optional => true},
          LONGITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'longitude', :optional => true},
          ALTITUDE => {:type => ::Thrift::Types::DOUBLE, :name => 'altitude', :optional => true},
          AUTHOR => {:type => ::Thrift::Types::STRING, :name => 'author', :optional => true},
          SOURCE => {:type => ::Thrift::Types::STRING, :name => 'source', :optional => true},
          SOURCEURL => {:type => ::Thrift::Types::STRING, :name => 'sourceURL', :optional => true},
          SOURCEAPPLICATION => {:type => ::Thrift::Types::STRING, :name => 'sourceApplication', :optional => true},
          SHAREDATE => {:type => ::Thrift::Types::I64, :name => 'shareDate', :optional => true},
          REMINDERORDER => {:type => ::Thrift::Types::I64, :name => 'reminderOrder', :optional => true},
          REMINDERDONETIME => {:type => ::Thrift::Types::I64, :name => 'reminderDoneTime', :optional => true},
          REMINDERTIME => {:type => ::Thrift::Types::I64, :name => 'reminderTime', :optional => true},
          PLACENAME => {:type => ::Thrift::Types::STRING, :name => 'placeName', :optional => true},
          CONTENTCLASS => {:type => ::Thrift::Types::STRING, :name => 'contentClass', :optional => true},
          APPLICATIONDATA => {:type => ::Thrift::Types::STRUCT, :name => 'applicationData', :class => ::Evernote::EDAM::Type::LazyMap, :optional => true},
          LASTEDITEDBY => {:type => ::Thrift::Types::STRING, :name => 'lastEditedBy', :optional => true},
          CLASSIFICATIONS => {:type => ::Thrift::Types::MAP, :name => 'classifications', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}, :optional => true},
          CREATORID => {:type => ::Thrift::Types::I32, :name => 'creatorId', :optional => true},
          LASTEDITORID => {:type => ::Thrift::Types::I32, :name => 'lastEditorId', :optional => true},
          SHAREDWITHBUSINESS => {:type => ::Thrift::Types::BOOL, :name => 'sharedWithBusiness', :optional => true},
          CONFLICTSOURCENOTEGUID => {:type => ::Thrift::Types::STRING, :name => 'conflictSourceNoteGuid', :optional => true},
          NOTETITLEQUALITY => {:type => ::Thrift::Types::I32, :name => 'noteTitleQuality', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Represents a relationship between a note and a single share invitation recipient. The recipient
# is identified via an Identity, and has a given privilege that specifies what actions they may
# take on the note.
# 
# <dl>
#   <dt>sharerUserID</dt>
#   <dd>The user ID of the user who shared the note with the recipient.</dd>
# 
#   <dt>recipientIdentity</dt>
#   <dd>The identity of the recipient of the share. For a given note, there may be only one
#     SharedNote per recipient identity. Only recipientIdentity.id is guaranteed to be set.
#     Other fields on the Identity may or my not be set based on the requesting user's
#     relationship with the recipient.</dd>
# 
#   <dt>privilege</dt>
#   <dd>The privilege level that the share grants to the recipient.</dd>
# 
#   <dt>serviceCreated</dt>
#   <dd>The time at which the share was created.</dd>
# 
#   <dt>serviceUpdated</dt>
#   <dd>The time at which the share was last updated.</dd>
# 
#   <dt>serviceAssigned</dt>
#   <dd>The time at which the share was assigned to a specific recipient user ID.</dd>
# </dl>
      class SharedNote
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SHARERUSERID = 1
        RECIPIENTIDENTITY = 2
        PRIVILEGE = 3
        SERVICECREATED = 4
        SERVICEUPDATED = 5
        SERVICEASSIGNED = 6

        FIELDS = {
          SHARERUSERID => {:type => ::Thrift::Types::I32, :name => 'sharerUserID', :optional => true},
          RECIPIENTIDENTITY => {:type => ::Thrift::Types::STRUCT, :name => 'recipientIdentity', :class => ::Evernote::EDAM::Type::Identity, :optional => true},
          PRIVILEGE => {:type => ::Thrift::Types::I32, :name => 'privilege', :optional => true, :enum_class => ::Evernote::EDAM::Type::SharedNotePrivilegeLevel},
          SERVICECREATED => {:type => ::Thrift::Types::I64, :name => 'serviceCreated', :optional => true},
          SERVICEUPDATED => {:type => ::Thrift::Types::I64, :name => 'serviceUpdated', :optional => true},
          SERVICEASSIGNED => {:type => ::Thrift::Types::I64, :name => 'serviceAssigned', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @privilege.nil? || ::Evernote::EDAM::Type::SharedNotePrivilegeLevel::VALID_VALUES.include?(@privilege)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field privilege!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # This structure captures information about the operations that cannot be performed on a given
# note that has been shared with a recipient via a SharedNote. The following operations are
# <b>never</b> allowed based on SharedNotes, and as such are left out of the NoteRestrictions
# structure for brevity:
# 
# <ul>
#   <li>Expunging a note (NoteStore.expungeNote)</li>
#   <li>Moving a note to the trash (Note.active)</li>
#   <li>Updating a note's notebook (Note.notebookGuid)</li>
#   <li>Updating a note's tags (Note.tagGuids, Note.tagNames)</li>
#   <li>Updating a note's attributes (Note.attributes)</li>
#   <li>Sharing a note with the business (NoteStore.shareNoteWithBusiness</li>
#   <li>Getting a note's version history (NoteStore.listNoteVersions,
#     NoteStore.getNoteVersion)</li>
# </ul>
# 
# When a client has permission to update a note's title or content, it may also update the
# Note.updated timestamp.
# 
# <b>This structure reflects only the privileges / restrictions conveyed by the SharedNote.</b>
# It does not incorporate privileges conveyed by a potential SharedNotebook to the same
# recipient. As such, the actual permissions that the recipient has on the note may differ from
# the permissions expressed in this structure.
# 
# For example, consider a user with read-only access to a shared notebook, and a read-write share
# of a specific note in the notebook. The note restrictions would contain noUpdateTitle = false,
# while the notebook restrictions would contain noUpdateNotes = true. In this case, the user is
# allowed to update the note title based on the note restrictions.
# 
# Alternatively, consider a user with read-write access to a shared notebook, and a read-only
# share of a specific note in that notebook. The note restrictions would contain
# noUpdateTitle = true, while the notebook restrictions would contain noUpdateNotes = false. In
# this case, the user would have full edit permissions on the note based on the notebook
# restrictions.
# 
# <dl>
#   <dt>noUpdateTitle</dt>
#   <dd>The client may not update the note's title (Note.title).</dd>
# 
#   <dt>noUpdateContent<dt>
#   <dd>The client may not update the note's content. Content includes Note.content
#     and Note.resources, as well as the related fields Note.contentHash and
#     Note.contentLength.</dd>
# 
#   <dt>noEmail</dt>
#   <dd>The client may not email the note (NoteStore.emailNote).</dd>
# 
#   <dt>noShare</dt>
#   <dd>The client may not share the note with specific recipients
#     (NoteStore.createOrUpdateSharedNotes).</dd>
# 
#   <dt>noSharePublicly</dt>
#   <dd>The client may not make the note public (NoteStore.shareNote).</dd>
# </dl>
      class NoteRestrictions
        include ::Thrift::Struct, ::Thrift::Struct_Union
        NOUPDATETITLE = 1
        NOUPDATECONTENT = 2
        NOEMAIL = 3
        NOSHARE = 4
        NOSHAREPUBLICLY = 5

        FIELDS = {
          NOUPDATETITLE => {:type => ::Thrift::Types::BOOL, :name => 'noUpdateTitle', :optional => true},
          NOUPDATECONTENT => {:type => ::Thrift::Types::BOOL, :name => 'noUpdateContent', :optional => true},
          NOEMAIL => {:type => ::Thrift::Types::BOOL, :name => 'noEmail', :optional => true},
          NOSHARE => {:type => ::Thrift::Types::BOOL, :name => 'noShare', :optional => true},
          NOSHAREPUBLICLY => {:type => ::Thrift::Types::BOOL, :name => 'noSharePublicly', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Represents a single note in the user's account.
# 
# <dl>
# <dt>guid</dt>
#   <dd>The unique identifier of this note.  Will be set by the
#   server, but will be omitted by clients calling NoteStore.createNote()
#   <br/>
#   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
#   <br/>
#   Regex:  EDAM_GUID_REGEX
#   </dd>
# 
# <dt>title</dt>
#   <dd>The subject of the note.  Can't begin or end with a space.
#   <br/>
#   Length:  EDAM_NOTE_TITLE_LEN_MIN - EDAM_NOTE_TITLE_LEN_MAX
#   <br/>
#   Regex:  EDAM_NOTE_TITLE_REGEX
#   </dd>
# 
# <dt>content</dt>
#   <dd>The XHTML block that makes up the note.  This is
#   the canonical form of the note's contents, so will include abstract
#   Evernote tags for internal resource references.  A client may create
#   a separate transformed version of this content for internal presentation,
#   but the same canonical bytes should be used for transmission and
#   comparison unless the user chooses to modify their content.
#   <br/>
#   Length:  EDAM_NOTE_CONTENT_LEN_MIN - EDAM_NOTE_CONTENT_LEN_MAX
#   </dd>
# 
# <dt>contentHash</dt>
#   <dd>The binary MD5 checksum of the UTF-8 encoded content
#   body. This will always be set by the server, but clients may choose to omit
#   this when they submit a note with content.
#   <br/>
#   Length:  EDAM_HASH_LEN (exactly)
#   </dd>
# 
# <dt>contentLength</dt>
#   <dd>The number of Unicode characters in the content of
#   the note.  This will always be set by the service, but clients may choose
#   to omit this value when they submit a Note.
#   </dd>
# 
# <dt>created</dt>
#   <dd>The date and time when the note was created in one of the
#   clients.  In most cases, this will match the user's sense of when
#   the note was created, and ordering between notes will be based on
#   ordering of this field.  However, this is not a "reliable" timestamp
#   if a client has an incorrect clock, so it cannot provide a true absolute
#   ordering between notes.  Notes created directly through the service
#   (e.g. via the web GUI) will have an absolutely ordered "created" value.
#   </dd>
# 
# <dt>updated</dt>
#   <dd>The date and time when the note was last modified in one of
#   the clients.  In most cases, this will match the user's sense of when
#   the note was modified, but this field may not be absolutely reliable
#   due to the possibility of client clock errors.
#   </dd>
# 
# <dt>deleted</dt>
#   <dd>If present, the note is considered "deleted", and this
#   stores the date and time when the note was deleted by one of the clients.
#   In most cases, this will match the user's sense of when the note was
#   deleted, but this field may be unreliable due to the possibility of
#   client clock errors.
#   </dd>
# 
# <dt>active</dt>
#   <dd>If the note is available for normal actions and viewing,
#   this flag will be set to true.
#   </dd>
# 
# <dt>updateSequenceNum</dt>
#   <dd>A number identifying the last transaction to
#   modify the state of this note (including changes to the note's attributes
#   or resources).  The USN values are sequential within an account,
#   and can be used to compare the order of modifications within the service.
#   </dd>
# 
# <dt>notebookGuid</dt>
#   <dd>The unique identifier of the notebook that contains
#   this note.  If no notebookGuid is provided on a call to createNote(), the
#   default notebook will be used instead.
#   <br/>
#   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
#   <br/>
#   Regex:  EDAM_GUID_REGEX
#   </dd>
# 
# <dt>tagGuids</dt>
#   <dd>A list of the GUID identifiers for tags that are applied to this note.
#   This may be provided in a call to createNote() to unambiguously declare
#   the tags that should be assigned to the new note.  Alternately, clients
#   may pass the names of desired tags via the 'tagNames' field during
#   note creation.
#   If the list of tags are omitted on a call to createNote(), then
#   the server will assume that no changes have been made to the resources.
#   Maximum:  EDAM_NOTE_TAGS_MAX tags per note
#   </dd>
# 
# <dt>resources</dt>
#   <dd>The list of resources that are embedded within this note.
#   If the list of resources are omitted on a call to updateNote(), then
#   the server will assume that no changes have been made to the resources.
#   The binary contents of the resources must be provided when the resource
#   is first sent to the service, but it will be omitted by the service when
#   the Note is returned in the future.
#   Maximum:  EDAM_NOTE_RESOURCES_MAX resources per note
#   </dd>
# 
# <dt>attributes</dt>
#   <dd>A list of the attributes for this note.
#   If the list of attributes are omitted on a call to updateNote(), then
#   the server will assume that no changes have been made to the resources.
#   </dd>
# 
# <dt>tagNames</dt>
#   <dd>May be provided by clients during calls to createNote() as an
#   alternative to providing the tagGuids of existing tags.  If any tagNames
#   are provided during createNote(), these will be found, or created if they
#   don't already exist.  Created tags will have no parent (they will be at
#   the top level of the tag panel).
#   </dd>
# 
# <dt>sharedNotes</dt>
#   <dd>The list of recipients with whom this note has been shared. This field will be unset if
#     the caller has access to the note via the containing notebook, but does not have activity
#     feed permission for that notebook. This field is read-only. Clients may not make changes to
#     a note's sharing state via this field.
#   </dd>
# 
#   <dt>restrictions</dt>
#   <dd>If this field is set, the user has note-level permissions that may differ from their
#     notebook-level permissions. In this case, the restrictions structure specifies
#     a set of restrictions limiting the actions that a user may take on the note based
#     on their note-level permissions. If this field is unset, then there are no
#     note-specific restrictions. However, a client may still be limited based on the user's
#     notebook permissions.</dd>
# </dl>
      class Note
        include ::Thrift::Struct, ::Thrift::Struct_Union
        GUID = 1
        TITLE = 2
        CONTENT = 3
        CONTENTHASH = 4
        CONTENTLENGTH = 5
        CREATED = 6
        UPDATED = 7
        DELETED = 8
        ACTIVE = 9
        UPDATESEQUENCENUM = 10
        NOTEBOOKGUID = 11
        TAGGUIDS = 12
        RESOURCES = 13
        ATTRIBUTES = 14
        TAGNAMES = 15
        SHAREDNOTES = 16
        RESTRICTIONS = 17

        FIELDS = {
          GUID => {:type => ::Thrift::Types::STRING, :name => 'guid', :optional => true},
          TITLE => {:type => ::Thrift::Types::STRING, :name => 'title', :optional => true},
          CONTENT => {:type => ::Thrift::Types::STRING, :name => 'content', :optional => true},
          CONTENTHASH => {:type => ::Thrift::Types::STRING, :name => 'contentHash', :binary => true, :optional => true},
          CONTENTLENGTH => {:type => ::Thrift::Types::I32, :name => 'contentLength', :optional => true},
          CREATED => {:type => ::Thrift::Types::I64, :name => 'created', :optional => true},
          UPDATED => {:type => ::Thrift::Types::I64, :name => 'updated', :optional => true},
          DELETED => {:type => ::Thrift::Types::I64, :name => 'deleted', :optional => true},
          ACTIVE => {:type => ::Thrift::Types::BOOL, :name => 'active', :optional => true},
          UPDATESEQUENCENUM => {:type => ::Thrift::Types::I32, :name => 'updateSequenceNum', :optional => true},
          NOTEBOOKGUID => {:type => ::Thrift::Types::STRING, :name => 'notebookGuid', :optional => true},
          TAGGUIDS => {:type => ::Thrift::Types::LIST, :name => 'tagGuids', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          RESOURCES => {:type => ::Thrift::Types::LIST, :name => 'resources', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Evernote::EDAM::Type::Resource}, :optional => true},
          ATTRIBUTES => {:type => ::Thrift::Types::STRUCT, :name => 'attributes', :class => ::Evernote::EDAM::Type::NoteAttributes, :optional => true},
          TAGNAMES => {:type => ::Thrift::Types::LIST, :name => 'tagNames', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          SHAREDNOTES => {:type => ::Thrift::Types::LIST, :name => 'sharedNotes', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Evernote::EDAM::Type::SharedNote}, :optional => true},
          RESTRICTIONS => {:type => ::Thrift::Types::STRUCT, :name => 'restrictions', :class => ::Evernote::EDAM::Type::NoteRestrictions, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # If a Notebook has been opened to the public, the Notebook will have a
# reference to one of these structures, which gives the location and optional
# description of the externally-visible public Notebook.
# <dl>
# <dt>uri</dt>
#   <dd>If this field is present, then the notebook is published for
#   mass consumption on the Internet under the provided URI, which is
#   relative to a defined base publishing URI defined by the service.
#   This field can only be modified via the web service GUI ... publishing
#   cannot be modified via an offline client.
#   <br/>
#   Length:  EDAM_PUBLISHING_URI_LEN_MIN - EDAM_PUBLISHING_URI_LEN_MAX
#   <br/>
#   Regex:  EDAM_PUBLISHING_URI_REGEX
#   </dd>
# 
# <dt>order</dt>
#   <dd>When the notes are publicly displayed, they will be sorted
#   based on the requested criteria.
#   </dd>
# 
# <dt>ascending</dt>
#   <dd>If this is set to true, then the public notes will be
#   displayed in ascending order (e.g. from oldest to newest).  Otherwise,
#   the notes will be displayed in descending order (e.g. newest to oldest).
#   </dd>
# 
# <dt>publicDescription</dt>
#   <dd>This field may be used to provide a short
#   description of the notebook, which may be displayed when (e.g.) the
#   notebook is shown in a public view.  Can't begin or end with a space.
#   <br/>
#   Length:  EDAM_PUBLISHING_DESCRIPTION_LEN_MIN -
#            EDAM_PUBLISHING_DESCRIPTION_LEN_MAX
#   <br/>
#   Regex:  EDAM_PUBLISHING_DESCRIPTION_REGEX
#   </dd>
# 
# </dl>
      class Publishing
        include ::Thrift::Struct, ::Thrift::Struct_Union
        URI = 1
        ORDER = 2
        ASCENDING = 3
        PUBLICDESCRIPTION = 4

        FIELDS = {
          URI => {:type => ::Thrift::Types::STRING, :name => 'uri', :optional => true},
          ORDER => {:type => ::Thrift::Types::I32, :name => 'order', :optional => true, :enum_class => ::Evernote::EDAM::Type::NoteSortOrder},
          ASCENDING => {:type => ::Thrift::Types::BOOL, :name => 'ascending', :optional => true},
          PUBLICDESCRIPTION => {:type => ::Thrift::Types::STRING, :name => 'publicDescription', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @order.nil? || ::Evernote::EDAM::Type::NoteSortOrder::VALID_VALUES.include?(@order)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field order!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # If a Notebook contained in an Evernote Business account has been published
# the to business library, the Notebook will have a reference to one of these
# structures, which specifies how the Notebook will be represented in the
# library.
# 
# <dl>
# <dt>notebookDescription</dt>
#   <dd>A short description of the notebook's content that will be displayed
#       in the business library user interface. The description may not begin
#       or end with whitespace.
#   <br/>
#   Length: EDAM_BUSINESS_NOTEBOOK_DESCRIPTION_LEN_MIN -
#           EDAM_BUSINESS_NOTEBOOK_DESCRIPTION_LEN_MAX
#   <br/>
#   Regex:  EDAM_BUSINESS_NOTEBOOK_DESCRIPTION_REGEX
#   </dd>
# 
# <dt>privilege</dt>
#   <dd>The privileges that will be granted to users who join the notebook through
#       the business library.
#   </dd>
# 
# <dt>recommended</dt>
#   <dd>Whether the notebook should be "recommended" when displayed in the business
#       library user interface.
#   </dd>
# </dl>
      class BusinessNotebook
        include ::Thrift::Struct, ::Thrift::Struct_Union
        NOTEBOOKDESCRIPTION = 1
        PRIVILEGE = 2
        RECOMMENDED = 3

        FIELDS = {
          NOTEBOOKDESCRIPTION => {:type => ::Thrift::Types::STRING, :name => 'notebookDescription', :optional => true},
          PRIVILEGE => {:type => ::Thrift::Types::I32, :name => 'privilege', :optional => true, :enum_class => ::Evernote::EDAM::Type::SharedNotebookPrivilegeLevel},
          RECOMMENDED => {:type => ::Thrift::Types::BOOL, :name => 'recommended', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @privilege.nil? || ::Evernote::EDAM::Type::SharedNotebookPrivilegeLevel::VALID_VALUES.include?(@privilege)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field privilege!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A structure defining the scope of a SavedSearch.
# 
# <dl>
#   <dt>includeAccount</dt>
#   <dd>The search should include notes from the account that contains the SavedSearch.</dd>
# 
#   <dt>includePersonalLinkedNotebooks</dt>
#   <dd>The search should include notes within those shared notebooks
#   that the user has joined that are NOT business notebooks.</dd>
# 
#   <dt>includeBusinessLinkedNotebooks</dt>
#   <dd>The search should include notes within those shared notebooks
#   that the user has joined that are business notebooks in the business that
#   the user is currently a member of.</dd>
# </dl>
      class SavedSearchScope
        include ::Thrift::Struct, ::Thrift::Struct_Union
        INCLUDEACCOUNT = 1
        INCLUDEPERSONALLINKEDNOTEBOOKS = 2
        INCLUDEBUSINESSLINKEDNOTEBOOKS = 3

        FIELDS = {
          INCLUDEACCOUNT => {:type => ::Thrift::Types::BOOL, :name => 'includeAccount', :optional => true},
          INCLUDEPERSONALLINKEDNOTEBOOKS => {:type => ::Thrift::Types::BOOL, :name => 'includePersonalLinkedNotebooks', :optional => true},
          INCLUDEBUSINESSLINKEDNOTEBOOKS => {:type => ::Thrift::Types::BOOL, :name => 'includeBusinessLinkedNotebooks', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A named search associated with the account that can be quickly re-used.
# <dl>
# <dt>guid</dt>
#   <dd>The unique identifier of this search.  Will be set by the
#   service, so may be omitted by the client when creating.
#   <br/>
#   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
#   <br/>
#   Regex:  EDAM_GUID_REGEX
#   </dd>
# 
# <dt>name</dt>
#   <dd>The name of the saved search to display in the GUI.  The
#   account may only contain one search with a given name (case-insensitive
#   compare). Can't begin or end with a space.
#   <br/>
#   Length:  EDAM_SAVED_SEARCH_NAME_LEN_MIN - EDAM_SAVED_SEARCH_NAME_LEN_MAX
#   <br/>
#   Regex:  EDAM_SAVED_SEARCH_NAME_REGEX
#   </dd>
# 
# <dt>query</dt>
#   <dd>A string expressing the search to be performed.
#   <br/>
#   Length:  EDAM_SAVED_SEARCH_QUERY_LEN_MIN - EDAM_SAVED_SEARCH_QUERY_LEN_MAX
#   </dd>
# 
# <dt>format</dt>
#   <dd>The format of the query string, to determine how to parse
#   and process it.
#   </dd>
# 
# <dt>updateSequenceNum</dt>
#   <dd>A number identifying the last transaction to
#   modify the state of this object.  The USN values are sequential within an
#   account, and can be used to compare the order of modifications within the
#   service.
#   </dd>
# 
# <dt>scope</dt>
#   <dd><p>Specifies the set of notes that should be included in the search, if
#    possible.</p>
#    <p>Clients are expected to search as much of the desired scope as possible,
#    with the understanding that a given client may not be able to cover the full
#    specified scope. For example, when executing a search that includes notes in both
#    the owner's account and business notebooks, a mobile client may choose to only
#    search within the user's account because it is not capable of searching both
#    scopes simultaneously. When a search across multiple scopes is not possible,
#    a client may choose which scope to search based on the current application
#    context. If a client cannot search any of the desired scopes, it should refuse
#    to execute the search.</p>
#    </dd>
# </dl>
      class SavedSearch
        include ::Thrift::Struct, ::Thrift::Struct_Union
        GUID = 1
        NAME = 2
        QUERY = 3
        FORMAT = 4
        UPDATESEQUENCENUM = 5
        SCOPE = 6

        FIELDS = {
          GUID => {:type => ::Thrift::Types::STRING, :name => 'guid', :optional => true},
          NAME => {:type => ::Thrift::Types::STRING, :name => 'name', :optional => true},
          QUERY => {:type => ::Thrift::Types::STRING, :name => 'query', :optional => true},
          FORMAT => {:type => ::Thrift::Types::I32, :name => 'format', :optional => true, :enum_class => ::Evernote::EDAM::Type::QueryFormat},
          UPDATESEQUENCENUM => {:type => ::Thrift::Types::I32, :name => 'updateSequenceNum', :optional => true},
          SCOPE => {:type => ::Thrift::Types::STRUCT, :name => 'scope', :class => ::Evernote::EDAM::Type::SavedSearchScope, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @format.nil? || ::Evernote::EDAM::Type::QueryFormat::VALID_VALUES.include?(@format)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field format!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # An advertisement that may be displayed within an Evernote client.
# Advertisements are either a snippet of HTML or else they
# are an image (of type: JPEG, GIF, PNG) with an associated destination URL.
# 
# <dl>
#   <dt>id</dt>
#   <dd>The unique identifier of this advertisement within Evernote's ad
#   inventory.
#   </dd>
# 
#   <dt>width</dt>
#   <dd>This ad should be displayed within a rectangle that is this wide,
#   in pixels.
#   </dd>
# 
#   <dt>height</dt>
#   <dd>This ad should be displayed within a rectangle that is this high,
#   in pixels.
#   </dd>
# 
#   <dt>advertiserName</dt>
#   <dd>A string containing a readable version of the name of this advertiser.
#   </dd>
# 
#   <dt>imageUrl</dt>
#   <dd>The location of the image to display for this ad.</dd>
# 
#   <dt>destinationUrl</dt>
#   <dd>When a user clicks on the ad, this is the destination they should be
#   sent to in a browser.</dd>
# 
#   <dt>displaySeconds</dt>
#   <dd>The number of seconds that the ad should be displayed before it is
#   replaced with a different ad.</dd>
# 
#   <dt>score</dt>
#   <dd>A numeric indicator of the relative value of this ad, which can be
#   compared against other ads from the same day.
#   </dd>
# 
#   <dt>image</dt>
#   <dd>If present, this is the raw image bits of the image file to display
#   for the ad.  If not present, the imageUrl should be retrieved directly.
#   </dd>
# 
#   <dt>imageMime</dt>
#   <dd>The MIME type of the 'image' bytes, if those are set.</dd>
# 
#   <dt>html</dt>
#   <dd>The exact HTML to display for this ad, to support rich or external
#   advertisements.</dd>
# 
#   <dt>displayFrequency</dt>
#   <dd>If this value is set, this is the relatively frequency that this
#   ad should be displayed in the daily set of ads, relative to a base
#   frequency of 1.0.  I.e. an ad with a frequency of 3.0 should be displayed
#   three times more frequently than an ad with a frequency of 1.0.</dd>
# 
#   <dt>openInTrunk</dt>
#   <dd>If true, the ad should be opened in the embedded Trunk window by
#   clients with Trunk support.</dd>
# </dl>
      class Ad
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ID = 1
        WIDTH = 2
        HEIGHT = 3
        ADVERTISERNAME = 4
        IMAGEURL = 5
        DESTINATIONURL = 6
        DISPLAYSECONDS = 7
        SCORE = 8
        IMAGE = 9
        IMAGEMIME = 10
        HTML = 11
        DISPLAYFREQUENCY = 12
        OPENINTRUNK = 13

        FIELDS = {
          ID => {:type => ::Thrift::Types::I32, :name => 'id', :optional => true},
          WIDTH => {:type => ::Thrift::Types::I16, :name => 'width', :optional => true},
          HEIGHT => {:type => ::Thrift::Types::I16, :name => 'height', :optional => true},
          ADVERTISERNAME => {:type => ::Thrift::Types::STRING, :name => 'advertiserName', :optional => true},
          IMAGEURL => {:type => ::Thrift::Types::STRING, :name => 'imageUrl', :optional => true},
          DESTINATIONURL => {:type => ::Thrift::Types::STRING, :name => 'destinationUrl', :optional => true},
          DISPLAYSECONDS => {:type => ::Thrift::Types::I16, :name => 'displaySeconds', :optional => true},
          SCORE => {:type => ::Thrift::Types::DOUBLE, :name => 'score', :optional => true},
          IMAGE => {:type => ::Thrift::Types::STRING, :name => 'image', :binary => true, :optional => true},
          IMAGEMIME => {:type => ::Thrift::Types::STRING, :name => 'imageMime', :optional => true},
          HTML => {:type => ::Thrift::Types::STRING, :name => 'html', :optional => true},
          DISPLAYFREQUENCY => {:type => ::Thrift::Types::DOUBLE, :name => 'displayFrequency', :optional => true},
          OPENINTRUNK => {:type => ::Thrift::Types::BOOL, :name => 'openInTrunk', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Settings meant for the recipient of a shared notebook, such as
# for indicating which types of notifications the recipient wishes
# for reminders, etc.
# 
# The reminderNotifyEmail and reminderNotifyInApp fields have a
# 3-state read value but a 2-state write value.  On read, it is
# possible to observe "unset", true, or false.  The initial state is
# "unset".  When you choose to set a value, you may set it to either
# true or false, but you cannot unset the value.  Once one of these
# members has a true/false value, it will always have a true/false
# value.
# 
# <dl>
# <dt>reminderNotifyEmail</dt>
# <dd>Indicates that the user wishes to receive daily e-mail notifications
#     for reminders associated with the notebook. This may be true only for
#     business notebooks that belong to the business of which the user is a
#     member. You may only set this value on a notebook in your business.</dd>
# <dt>reminderNotifyInApp</dt>
# <dd>Indicates that the user wishes to receive notifications for
#     reminders by applications that support providing such
#     notifications.  The exact nature of the notification is defined
#     by the individual applications.</dd>
# </dl>
# 
      class SharedNotebookRecipientSettings
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REMINDERNOTIFYEMAIL = 1
        REMINDERNOTIFYINAPP = 2

        FIELDS = {
          REMINDERNOTIFYEMAIL => {:type => ::Thrift::Types::BOOL, :name => 'reminderNotifyEmail', :optional => true},
          REMINDERNOTIFYINAPP => {:type => ::Thrift::Types::BOOL, :name => 'reminderNotifyInApp', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Settings meant for the recipient of a notebook share.
# 
# Some of these fields have a 3-state read value but a 2-state write value.
# On read, it is possible to observe "unset", true, or false. The initial
# state is "unset". When you choose to set a value, you may set it to either
# true or false, but you cannot unset the value. Once one of these members
# has a true/false value, it will always have a true/false value.
# 
# <dl>
# <dt>reminderNotifyEmail</dt>
# <dd>Indicates that the user wishes to receive daily e-mail notifications
#     for reminders associated with the notebook. This may be
#     true only for business notebooks that belong to the business of
#     which the user is a member. You may only set this value on a
#     notebook in your business. This value will initially be unset.</dd>
# <dt>reminderNotifyInApp</dt>
# <dd>Indicates that the user wishes to receive notifications for
#     reminders by applications that support providing such
#     notifications.  The exact nature of the notification is defined
#     by the individual applications. This value will initially be unset.</dd>
# </dl>
# <dt>inMyList</dt>
# <dd>The notebook is on the recipient's notebook list (formerly, we would say
#     that the recipient has "joined" the notebook)</dd>
# <dt>stack</dt>
# <dd>The stack the recipient has put this notebook into. See Notebook.stack
# for a definition. Every recipient can have their own stack value for the same
# notebook.</dd>
# </dl>
# 
      class NotebookRecipientSettings
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REMINDERNOTIFYEMAIL = 1
        REMINDERNOTIFYINAPP = 2
        INMYLIST = 3
        STACK = 4

        FIELDS = {
          REMINDERNOTIFYEMAIL => {:type => ::Thrift::Types::BOOL, :name => 'reminderNotifyEmail', :optional => true},
          REMINDERNOTIFYINAPP => {:type => ::Thrift::Types::BOOL, :name => 'reminderNotifyInApp', :optional => true},
          INMYLIST => {:type => ::Thrift::Types::BOOL, :name => 'inMyList', :optional => true},
          STACK => {:type => ::Thrift::Types::STRING, :name => 'stack', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Shared notebooks represent a relationship between a notebook and a single
# share invitation recipient.
# <dl>
# <dt>id</dt>
# <dd>The primary identifier of the share, which is not globally unique.</dd>
# 
# <dt>userId</dt>
# <dd>The user id of the owner of the notebook.</dd>
# 
# <dt>notebookGuid</dt>
# <dd>The GUID of the notebook that has been shared.</dd>
# 
# <dt>email</dt>
# <dd>A string containing a display name for the recipient of the share. This may
#     be an email address, a phone number, a full name, or some other descriptive
#     string This field is read-only to clients. It will be filled in by the service
#     when returning shared notebooks.
# </dd>
# 
# <dt>recipientIdentityId</dt>
# <dd>The IdentityID of the share recipient. If present, only the user who has
#     claimed that identity may access this share.
# </dd>
# 
# <dt>notebookModifiable</dt>
# <dd>DEPRECATED</dd>
# 
# <dt>requireLogin</dt>
# <dd>DEPRECATED</dd>
# 
# <dt>serviceCreated</dt>
# <dd>The date that the owner first created the share with the specific email
#   address.</dd>
# 
# <dt>serviceUpdated</dt>
# <dd>The date the shared notebook was last updated on the service.  This
#     will be updated when authenticateToSharedNotebook is called the first
#     time with a shared notebook (i.e. when the username is bound to that
#     shared notebook), and also when the SharedNotebook privilege is updated
#     as part of a shareNotebook(...) call, as well as on any calls to
#     updateSharedNotebook(...).
# </dd>
# 
# <dt>username</dt>
# <dd>DEPRECATED. The username of the user who can access this share. This
#     value is read-only to clients. It will be filled in by the service when
#     returning shared notebooks.
# </dd>
# 
# <dt>privilege</dt>
# <dd>The privilege level granted to the notebook, activity stream, and
#     invitations.  See the corresponding enumeration for details.
# </dd>
# 
# <dt>allowPreview</dt>
# <dd>Whether or not to grant "READ_NOTEBOOK" privilege without an
#     authentication token, for authenticateToSharedNotebook(...).  With
#     the change to "requireLogin" always being true for new shared
#     notebooks, this is the only way to access a shared notebook without
#     an authorization token.  This setting expires after the first use
#     of authenticateToSharedNotebook(...) with a valid authentication
#     token.
# </dd>
# 
# <dt>recipientSettings</dt>
# <dd>Settings intended for use only by the recipient of this shared
#     notebook.  You should skip setting this value unless you want
#     to change the value contained inside the structure, and only if
#     you are the recipient.</dd>
# 
# <dt>globalId</dt>
# <dd>An immutable, opaque string that acts as a globally unique
#     identifier for this shared notebook record.  You can use this field to
#     match linked notebook and shared notebook records as well as to
#     create new LinkedNotebook records.  This field replaces the deprecated
#     shareKey field.
# </dd>
# 
# <dt>sharerUserId</dt>
# <dd>The user id of the user who shared a notebook via this shared notebook
#     instance. This may not be the same as userId, since a user with full
#     access to a notebook may have created a new share for that notebook. For
#     Business, this represents the user who shared the business notebook. This
#     field is currently unset for a SharedNotebook created by joining a
#     notebook that has been published to the business.
# </dd>
# 
# <dt>recipientUsername</dt>
# <dd>The username of the user who can access this share. This is the username
#     for the user with the id in recipientUserId. This value can be set
#     by clients when calling shareNotebook(...), and that will result in the
#     created SharedNotebook being assigned to a user. This value is always set
#     if serviceAssigned is set.
# </dd>
# 
# <dt>recipientUserId</dt>
# <dd>The id of the user who can access this share. This is the id for the user
#     with the username in recipientUsername. This value is read-only and set
#     by the service. Value set by clients will be ignored. This field may be unset
#     for unjoined notebooks and is always set if serviceAssigned is set. Clients should
#     prefer this field over recipientUsername unless they need to use usernames
#     directly.
# </dd>
# 
# <dt>serviceAssigned</dt>
# <dd>The date this SharedNotebook was assigned (i.e. has been associated with an
#     Evernote user whose user ID is set in recipientUserId). Unset if the SharedNotebook
#     is not assigned. This field is a read-only value that is set by the service.
# </dd>
# </dl>
      class SharedNotebook
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ID = 1
        USERID = 2
        NOTEBOOKGUID = 3
        EMAIL = 4
        RECIPIENTIDENTITYID = 18
        NOTEBOOKMODIFIABLE = 5
        REQUIRELOGIN = 6
        SERVICECREATED = 7
        SERVICEUPDATED = 10
        GLOBALID = 8
        USERNAME = 9
        PRIVILEGE = 11
        ALLOWPREVIEW = 12
        RECIPIENTSETTINGS = 13
        SHARERUSERID = 14
        RECIPIENTUSERNAME = 15
        RECIPIENTUSERID = 17
        SERVICEASSIGNED = 16

        FIELDS = {
          ID => {:type => ::Thrift::Types::I64, :name => 'id', :optional => true},
          USERID => {:type => ::Thrift::Types::I32, :name => 'userId', :optional => true},
          NOTEBOOKGUID => {:type => ::Thrift::Types::STRING, :name => 'notebookGuid', :optional => true},
          EMAIL => {:type => ::Thrift::Types::STRING, :name => 'email', :optional => true},
          RECIPIENTIDENTITYID => {:type => ::Thrift::Types::I64, :name => 'recipientIdentityId', :optional => true},
          NOTEBOOKMODIFIABLE => {:type => ::Thrift::Types::BOOL, :name => 'notebookModifiable', :optional => true},
          REQUIRELOGIN => {:type => ::Thrift::Types::BOOL, :name => 'requireLogin', :optional => true},
          SERVICECREATED => {:type => ::Thrift::Types::I64, :name => 'serviceCreated', :optional => true},
          SERVICEUPDATED => {:type => ::Thrift::Types::I64, :name => 'serviceUpdated', :optional => true},
          GLOBALID => {:type => ::Thrift::Types::STRING, :name => 'globalId', :optional => true},
          USERNAME => {:type => ::Thrift::Types::STRING, :name => 'username', :optional => true},
          PRIVILEGE => {:type => ::Thrift::Types::I32, :name => 'privilege', :optional => true, :enum_class => ::Evernote::EDAM::Type::SharedNotebookPrivilegeLevel},
          ALLOWPREVIEW => {:type => ::Thrift::Types::BOOL, :name => 'allowPreview', :optional => true},
          RECIPIENTSETTINGS => {:type => ::Thrift::Types::STRUCT, :name => 'recipientSettings', :class => ::Evernote::EDAM::Type::SharedNotebookRecipientSettings, :optional => true},
          SHARERUSERID => {:type => ::Thrift::Types::I32, :name => 'sharerUserId', :optional => true},
          RECIPIENTUSERNAME => {:type => ::Thrift::Types::STRING, :name => 'recipientUsername', :optional => true},
          RECIPIENTUSERID => {:type => ::Thrift::Types::I32, :name => 'recipientUserId', :optional => true},
          SERVICEASSIGNED => {:type => ::Thrift::Types::I64, :name => 'serviceAssigned', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @privilege.nil? || ::Evernote::EDAM::Type::SharedNotebookPrivilegeLevel::VALID_VALUES.include?(@privilege)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field privilege!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # This structure captures information about the types of operations
# that cannot be performed on a given notebook with a type of
# authenticated access and credentials.  The values filled into this
# structure are based on then-current values in the server database
# for shared notebooks and notebook publishing records, as well as
# information related to the authentication token.  Information from
# the authentication token includes the application that is accessing
# the server, as defined by the permissions granted by consumer (api)
# key, and the method used to obtain the token, for example via
# authenticateToSharedNotebook, authenticateToBusiness, etc.  Note
# that changes to values in this structure that are the result of
# shared notebook or publishing record changes are communicated to
# the client via a change in the notebook USN during sync.  It is
# important to use the same access method, parameters, and consumer
# key in order obtain correct results from the sync engine.
# 
# The server has the final say on what is allowed as values may
# change between calls to obtain NotebookRestrictions instances
# and to operate on data on the service.
# 
# If the following are set and true, then the given restriction is
# in effect, as accessed by the same authentication token from which
# the values were obtained.
# 
# <dt>noReadNotes</dt>
#   <dd>The client is not able to read notes from the service and
#   the notebook is write-only.
#   </dd>
# <dt>noCreateNotes</dt>
#   <dd>The client may not create new notes in the notebook.
#   </dd>
# <dt>noUpdateNotes</dt>
#   <dd>The client may not update notes currently in the notebook.
#   </dd>
# <dt>noExpungeNotes</dt>
#   <dd>The client may not expunge notes currently in the notebook.
#   </dd>
# <dt>noShareNotes</dt>
#   <dd>The client may not share notes in the notebook via the
#   shareNote or createOrUpdateSharedNotes methods.
#   </dd>
# <dt>noEmailNotes</dt>
#   <dd>The client may not e-mail notes via the Evernote service by
#   using the emailNote method.
#   </dd>
# <dt>noSendMessageToRecipients</dt>
#   <dd>The client may not send messages to the share recipients of
#   the notebook.
#   </dd>
# <dt>noUpdateNotebook</dt>
#   <dd>The client may not update the Notebook object itself, for
#   example, via the updateNotebook method.
#   </dd>
# <dt>noExpungeNotebook</dt>
#   <dd>The client may not expunge the Notebook object itself, for
#   example, via the expungeNotebook method.
#   </dd>
# <dt>noSetDefaultNotebook</dt>
#   <dd>The client may not set this notebook to be the default notebook.
#   The caller should leave Notebook.defaultNotebook unset.
#   </dd>
# <dt>noSetNotebookStack</dt>
#   <dd>If the client is able to update the Notebook, the Notebook.stack
#   value may not be set.
#   </dd>
# <dt>noPublishToPublic</dt>
#   <dd>The client may not publish the notebook to the public.
#   For example, business notebooks may not be shared publicly.
#   </dd>
# <dt>noPublishToBusinessLibrary</dt>
#   <dd>The client may not publish the notebook to the business library.
#   </dd>
# <dt>noCreateTags</dt>
#   <dd>The client may not complete an operation that results in a new tag
#   being created in the owner's account.
#   </dd>
# <dt>noUpdateTags</dt>
#   <dd>The client may not update tags in the owner's account.
#   </dd>
# <dt>noExpungeTags</dt>
#   <dd>The client may not expunge tags in the owner's account.
#   </dd>
# <dt>noSetParentTag</dt>
#   <dd>If the client is able to create or update tags in the owner's account,
#   then they will not be able to set the parent tag.  Leave the value unset.
#   </dd>
# <dt>noCreateSharedNotebooks</dt>
#   <dd>The client is unable to create shared notebooks for the notebook.
#   </dd>
# <dt>updateWhichSharedNotebookRestrictions</dt>
#   <dd>Restrictions on which shared notebook instances can be updated.  If the
#   value is not set or null, then the client can update any of the shared notebooks
#   associated with the notebook on which the NotebookRestrictions are defined.
#   See the enumeration for further details.
#   </dd>
# <dt>expungeWhichSharedNotebookRestrictions</dt>
#   <dd>Restrictions on which shared notebook instances can be expunged.  If the
#   value is not set or null, then the client can expunge any of the shared notebooks
#   associated with the notebook on which the NotebookRestrictions are defined.
#   See the enumeration for further details.
#   </dd>
# <dt>noShareNotesWithBusiness</dt>
#   <dd>The client may not share notes in the notebook via the shareNoteWithBusiness
#   method.
#   </dd>
      class NotebookRestrictions
        include ::Thrift::Struct, ::Thrift::Struct_Union
        NOREADNOTES = 1
        NOCREATENOTES = 2
        NOUPDATENOTES = 3
        NOEXPUNGENOTES = 4
        NOSHARENOTES = 5
        NOEMAILNOTES = 6
        NOSENDMESSAGETORECIPIENTS = 7
        NOUPDATENOTEBOOK = 8
        NOEXPUNGENOTEBOOK = 9
        NOSETDEFAULTNOTEBOOK = 10
        NOSETNOTEBOOKSTACK = 11
        NOPUBLISHTOPUBLIC = 12
        NOPUBLISHTOBUSINESSLIBRARY = 13
        NOCREATETAGS = 14
        NOUPDATETAGS = 15
        NOEXPUNGETAGS = 16
        NOSETPARENTTAG = 17
        NOCREATESHAREDNOTEBOOKS = 18
        UPDATEWHICHSHAREDNOTEBOOKRESTRICTIONS = 19
        EXPUNGEWHICHSHAREDNOTEBOOKRESTRICTIONS = 20
        NOSHARENOTESWITHBUSINESS = 21

        FIELDS = {
          NOREADNOTES => {:type => ::Thrift::Types::BOOL, :name => 'noReadNotes', :optional => true},
          NOCREATENOTES => {:type => ::Thrift::Types::BOOL, :name => 'noCreateNotes', :optional => true},
          NOUPDATENOTES => {:type => ::Thrift::Types::BOOL, :name => 'noUpdateNotes', :optional => true},
          NOEXPUNGENOTES => {:type => ::Thrift::Types::BOOL, :name => 'noExpungeNotes', :optional => true},
          NOSHARENOTES => {:type => ::Thrift::Types::BOOL, :name => 'noShareNotes', :optional => true},
          NOEMAILNOTES => {:type => ::Thrift::Types::BOOL, :name => 'noEmailNotes', :optional => true},
          NOSENDMESSAGETORECIPIENTS => {:type => ::Thrift::Types::BOOL, :name => 'noSendMessageToRecipients', :optional => true},
          NOUPDATENOTEBOOK => {:type => ::Thrift::Types::BOOL, :name => 'noUpdateNotebook', :optional => true},
          NOEXPUNGENOTEBOOK => {:type => ::Thrift::Types::BOOL, :name => 'noExpungeNotebook', :optional => true},
          NOSETDEFAULTNOTEBOOK => {:type => ::Thrift::Types::BOOL, :name => 'noSetDefaultNotebook', :optional => true},
          NOSETNOTEBOOKSTACK => {:type => ::Thrift::Types::BOOL, :name => 'noSetNotebookStack', :optional => true},
          NOPUBLISHTOPUBLIC => {:type => ::Thrift::Types::BOOL, :name => 'noPublishToPublic', :optional => true},
          NOPUBLISHTOBUSINESSLIBRARY => {:type => ::Thrift::Types::BOOL, :name => 'noPublishToBusinessLibrary', :optional => true},
          NOCREATETAGS => {:type => ::Thrift::Types::BOOL, :name => 'noCreateTags', :optional => true},
          NOUPDATETAGS => {:type => ::Thrift::Types::BOOL, :name => 'noUpdateTags', :optional => true},
          NOEXPUNGETAGS => {:type => ::Thrift::Types::BOOL, :name => 'noExpungeTags', :optional => true},
          NOSETPARENTTAG => {:type => ::Thrift::Types::BOOL, :name => 'noSetParentTag', :optional => true},
          NOCREATESHAREDNOTEBOOKS => {:type => ::Thrift::Types::BOOL, :name => 'noCreateSharedNotebooks', :optional => true},
          UPDATEWHICHSHAREDNOTEBOOKRESTRICTIONS => {:type => ::Thrift::Types::I32, :name => 'updateWhichSharedNotebookRestrictions', :optional => true, :enum_class => ::Evernote::EDAM::Type::SharedNotebookInstanceRestrictions},
          EXPUNGEWHICHSHAREDNOTEBOOKRESTRICTIONS => {:type => ::Thrift::Types::I32, :name => 'expungeWhichSharedNotebookRestrictions', :optional => true, :enum_class => ::Evernote::EDAM::Type::SharedNotebookInstanceRestrictions},
          NOSHARENOTESWITHBUSINESS => {:type => ::Thrift::Types::BOOL, :name => 'noShareNotesWithBusiness', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @updateWhichSharedNotebookRestrictions.nil? || ::Evernote::EDAM::Type::SharedNotebookInstanceRestrictions::VALID_VALUES.include?(@updateWhichSharedNotebookRestrictions)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field updateWhichSharedNotebookRestrictions!')
          end
          unless @expungeWhichSharedNotebookRestrictions.nil? || ::Evernote::EDAM::Type::SharedNotebookInstanceRestrictions::VALID_VALUES.include?(@expungeWhichSharedNotebookRestrictions)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field expungeWhichSharedNotebookRestrictions!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A unique container for a set of notes.
# <dl>
# <dt>guid</dt>
#   <dd>The unique identifier of this notebook.
#   <br/>
#   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
#   <br/>
#   Regex:  EDAM_GUID_REGEX
#   </dd>
# 
# <dt>name</dt>
#   <dd>A sequence of characters representing the name of the
#   notebook.  May be changed by clients, but the account may not contain two
#   notebooks with names that are equal via a case-insensitive comparison.
#   Can't begin or end with a space.
#   <br/>
#   Length:  EDAM_NOTEBOOK_NAME_LEN_MIN - EDAM_NOTEBOOK_NAME_LEN_MAX
#   <br/>
#   Regex:  EDAM_NOTEBOOK_NAME_REGEX
#   </dd>
# 
# <dt>updateSequenceNum</dt>
#   <dd>A number identifying the last transaction to
#   modify the state of this object.  The USN values are sequential within an
#   account, and can be used to compare the order of modifications within the
#   service.
#   </dd>
# 
# <dt>defaultNotebook</dt>
#   <dd>If true, this notebook should be used for new notes
#   whenever the user has not (or cannot) specify a desired target notebook.
#   For example, if a note is submitted via SMTP email.
#   The service will maintain at most one defaultNotebook per account.
#   If a second notebook is created or updated with defaultNotebook set to
#   true, the service will automatically update the prior notebook's
#   defaultNotebook field to false.  If the default notebook is deleted
#   (i.e. "active" set to false), the "defaultNotebook" field will be
#   set to false by the service.  If the account has no default notebook
#   set, the service will use the most recent notebook as the default.
#   </dd>
# 
# <dt>serviceCreated</dt>
#   <dd>The time when this notebook was created on the
#   service. This will be set on the service during creation, and the service
#   will provide this value when it returns a Notebook to a client.
#   The service will ignore this value if it is sent by clients.
#   </dd>
# 
# <dt>serviceUpdated</dt>
#   <dd>The time when this notebook was last modified on the
#   service.  This will be set on the service during creation, and the service
#   will provide this value when it returns a Notebook to a client.
#   The service will ignore this value if it is sent by clients.
#   </dd>
# 
# <dt>publishing</dt>
#   <dd>If the Notebook has been opened for public access, then this will point to the set of
#   publishing information for the Notebook (URI, description, etc.). A Notebook cannot be
#   published without providing this information, but it will persist for later use if publishing
#   is ever disabled on the Notebook. Clients that do not wish to change the publishing behavior
#   of a Notebook should not set this value when calling NoteStore.updateNotebook().
#   Note that this structure is never populated for business notebooks, see the businessNotebook
#   field.
#   </dd>
# 
# <dt>published</dt>
#   <dd>If this is set to true, then the Notebook will be
#   accessible either to the public, or for business users to their business,
#   via the 'publishing' or 'businessNotebook' specifications, which must also be set. If this is
#   set to false, the Notebook will not be available to the public (or business).
#   Clients that do not wish to change the publishing behavior of a Notebook
#   should not set this value when calling NoteStore.updateNotebook().
#   </dd>
# 
# <dt>stack</dt>
#   <dd>If this is set, then the notebook is visually contained within a stack
#   of notebooks with this name.  All notebooks in the same account with the
#   same 'stack' field are considered to be in the same stack.
#   Notebooks with no stack set are "top level" and not contained within a
#   stack.
#   </dd>
# 
# <dt>sharedNotebookIds</dt>
#   <dd><i>DEPRECATED</i> - replaced by sharedNotebooks.</dd>
# 
# <dt>sharedNotebooks</dt>
#   <dd>The list of recipients to whom this notebook has been shared
#   (one SharedNotebook object per recipient email address). This field will
#   be unset if you do not have permission to access this data. If you are
#   accessing the notebook as the owner or via a shared notebook that is
#   modifiable, then you have access to this data and the value will be set.
#   This field is read-only. Clients may not make changes to shared notebooks
#   via this field.
#   </dd>
# 
# <dt>businessNotebook</dt>
#   <dd>If the notebook is part of a business account and has been shared with the entire
#   business, this will contain sharing information. The presence or absence of this field
#   is not a reliable test of whether a given notebook is in fact a business notebook - the
#   field is only used when a notebook is or has been shared with the entire business.
#   </dd>
# 
# <dt>contact</dt>
#   <dd>Intended for use with Business accounts, this field identifies the user who
#   has been designated as the "contact".  For notebooks created in business
#   accounts, the server will automatically set this value to the user who created
#   the notebook unless Notebook.contact.username has been set, in which that value
#   will be used.  When updating a notebook, it is common to leave Notebook.contact
#   field unset, indicating that no change to the value is being requested and that
#   the existing value, if any, should be preserved.
#   </dd>
# 
# <dt>recipientSettings</dt>
#   <dd>This represents the preferences/settings that a recipient has set for this
#   notebook. These are intended to be changed only by the recipient, and each
#   recipient has their own recipient settings.
#   </dd>
# </dl>
      class Notebook
        include ::Thrift::Struct, ::Thrift::Struct_Union
        GUID = 1
        NAME = 2
        UPDATESEQUENCENUM = 5
        DEFAULTNOTEBOOK = 6
        SERVICECREATED = 7
        SERVICEUPDATED = 8
        PUBLISHING = 10
        PUBLISHED = 11
        STACK = 12
        SHAREDNOTEBOOKIDS = 13
        SHAREDNOTEBOOKS = 14
        BUSINESSNOTEBOOK = 15
        CONTACT = 16
        RESTRICTIONS = 17
        RECIPIENTSETTINGS = 18

        FIELDS = {
          GUID => {:type => ::Thrift::Types::STRING, :name => 'guid', :optional => true},
          NAME => {:type => ::Thrift::Types::STRING, :name => 'name', :optional => true},
          UPDATESEQUENCENUM => {:type => ::Thrift::Types::I32, :name => 'updateSequenceNum', :optional => true},
          DEFAULTNOTEBOOK => {:type => ::Thrift::Types::BOOL, :name => 'defaultNotebook', :optional => true},
          SERVICECREATED => {:type => ::Thrift::Types::I64, :name => 'serviceCreated', :optional => true},
          SERVICEUPDATED => {:type => ::Thrift::Types::I64, :name => 'serviceUpdated', :optional => true},
          PUBLISHING => {:type => ::Thrift::Types::STRUCT, :name => 'publishing', :class => ::Evernote::EDAM::Type::Publishing, :optional => true},
          PUBLISHED => {:type => ::Thrift::Types::BOOL, :name => 'published', :optional => true},
          STACK => {:type => ::Thrift::Types::STRING, :name => 'stack', :optional => true},
          SHAREDNOTEBOOKIDS => {:type => ::Thrift::Types::LIST, :name => 'sharedNotebookIds', :element => {:type => ::Thrift::Types::I64}, :optional => true},
          SHAREDNOTEBOOKS => {:type => ::Thrift::Types::LIST, :name => 'sharedNotebooks', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Evernote::EDAM::Type::SharedNotebook}, :optional => true},
          BUSINESSNOTEBOOK => {:type => ::Thrift::Types::STRUCT, :name => 'businessNotebook', :class => ::Evernote::EDAM::Type::BusinessNotebook, :optional => true},
          CONTACT => {:type => ::Thrift::Types::STRUCT, :name => 'contact', :class => ::Evernote::EDAM::Type::User, :optional => true},
          RESTRICTIONS => {:type => ::Thrift::Types::STRUCT, :name => 'restrictions', :class => ::Evernote::EDAM::Type::NotebookRestrictions, :optional => true},
          RECIPIENTSETTINGS => {:type => ::Thrift::Types::STRUCT, :name => 'recipientSettings', :class => ::Evernote::EDAM::Type::NotebookRecipientSettings, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A link in a user's account that refers them to a public or
# individual shared notebook in another user's account.
# 
# <dl>
# <dt>shareName</dt>
# <dd>The display name of the shared notebook. The link owner can change this.</dd>
# 
# <dt>username</dt>
# <dd>The username of the user who owns the shared or public notebook.</dd>
# 
# <dt>shardId</dt>
# <dd>The shard ID of the notebook if the notebook is not public.</dt>
# 
# <dt>uri</dt>
# <dd>The identifier of the public notebook.</dd>
# 
# <dt>guid</dt>
#   <dd>The unique identifier of this linked notebook.  Will be set whenever
#   a linked notebook is retrieved from the service, but may be null when a client
#   is creating a linked notebook.
#   <br/>
#   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
#   <br/>
#   Regex:  EDAM_GUID_REGEX
#   </dd>
# 
# <dt>updateSequenceNum</dt>
#   <dd>A number identifying the last transaction to
#   modify the state of this object.  The USN values are sequential within an
#   account, and can be used to compare the order of modifications within the
#   service.
#   </dd>
# 
# <dt>noteStoreUrl</dt>
#   <dd>
#   This field will contain the full URL that clients should use to make
#   NoteStore requests to the server shard that contains that notebook's data.
#   I.e. this is the URL that should be used to create the Thrift HTTP client
#   transport to send messages to the NoteStore service for the account.
#   </dd>
# 
# <dt>webApiUrlPrefix:</dt>
#   <dd>
#   This field will contain the initial part of the URLs that should be used
#   to make requests to Evernote's thin client "web API", which provide
#   optimized operations for clients that aren't capable of manipulating
#   the full contents of accounts via the full Thrift data model. Clients
#   should concatenate the relative path for the various servlets onto the
#   end of this string to construct the full URL, as documented on our
#   developer web site.
#   </dd>
# 
# <dt>stack</dt>
#   <dd>If this is set, then the notebook is visually contained within a stack
#   of notebooks with this name.  All notebooks in the same account with the
#   same 'stack' field are considered to be in the same stack.
#   Notebooks with no stack set are "top level" and not contained within a
#   stack.  The link owner can change this and this field is for the benefit
#   of the link owner.
#   </dd>
# 
# <dt>businessId</dt>
#   <dd>If set, this will be the unique identifier for the business that owns
#   the notebook to which the linked notebook refers.</dd>
# 
# <dt>sharedNotebookGlobalId</dt>
#   <dd>The globally unique identifier (globalId) of the shared notebook that
#   corresponds to the share key, or the GUID of the Notebook that the linked notebook
#   refers to. This field must be filled in with the SharedNotebook.globalId or
#   Notebook.GUID value when creating new LinkedNotebooks. This field replaces the
#   deprecated "shareKey" field.
#   </dd>
# </dl>
      class LinkedNotebook
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SHARENAME = 2
        USERNAME = 3
        SHARDID = 4
        SHAREDNOTEBOOKGLOBALID = 5
        URI = 6
        GUID = 7
        UPDATESEQUENCENUM = 8
        NOTESTOREURL = 9
        WEBAPIURLPREFIX = 10
        STACK = 11
        BUSINESSID = 12

        FIELDS = {
          SHARENAME => {:type => ::Thrift::Types::STRING, :name => 'shareName', :optional => true},
          USERNAME => {:type => ::Thrift::Types::STRING, :name => 'username', :optional => true},
          SHARDID => {:type => ::Thrift::Types::STRING, :name => 'shardId', :optional => true},
          SHAREDNOTEBOOKGLOBALID => {:type => ::Thrift::Types::STRING, :name => 'sharedNotebookGlobalId', :optional => true},
          URI => {:type => ::Thrift::Types::STRING, :name => 'uri', :optional => true},
          GUID => {:type => ::Thrift::Types::STRING, :name => 'guid', :optional => true},
          UPDATESEQUENCENUM => {:type => ::Thrift::Types::I32, :name => 'updateSequenceNum', :optional => true},
          NOTESTOREURL => {:type => ::Thrift::Types::STRING, :name => 'noteStoreUrl', :optional => true},
          WEBAPIURLPREFIX => {:type => ::Thrift::Types::STRING, :name => 'webApiUrlPrefix', :optional => true},
          STACK => {:type => ::Thrift::Types::STRING, :name => 'stack', :optional => true},
          BUSINESSID => {:type => ::Thrift::Types::I32, :name => 'businessId', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A structure that describes a notebook or a user's relationship with
# a notebook. NotebookDescriptor is expected to remain a lighter-weight
# structure when compared to Notebook.
# <dl>
# <dt>guid</dt>
#   <dd>The unique identifier of the notebook.
#   </dd>
# 
# <dt>notebookDisplayName</dt>
#   <dd>A sequence of characters representing the name of the
#   notebook.
#   </dd>
# 
# <dt>contactName</dt>
#   <dd>The User.name value of the notebook's "contact".
#   </dd>
# 
# <dt>hasSharedNotebook</dt>
#   <dd>Whether a SharedNotebook record exists between the calling user and this
#   notebook.
#   </dd>
# 
# <dt>joinedUserCount</dt>
#   <dd>The number of users who have joined this notebook.
#   </dd>
# 
# </dl>
      class NotebookDescriptor
        include ::Thrift::Struct, ::Thrift::Struct_Union
        GUID = 1
        NOTEBOOKDISPLAYNAME = 2
        CONTACTNAME = 3
        HASSHAREDNOTEBOOK = 4
        JOINEDUSERCOUNT = 5

        FIELDS = {
          GUID => {:type => ::Thrift::Types::STRING, :name => 'guid', :optional => true},
          NOTEBOOKDISPLAYNAME => {:type => ::Thrift::Types::STRING, :name => 'notebookDisplayName', :optional => true},
          CONTACTNAME => {:type => ::Thrift::Types::STRING, :name => 'contactName', :optional => true},
          HASSHAREDNOTEBOOK => {:type => ::Thrift::Types::BOOL, :name => 'hasSharedNotebook', :optional => true},
          JOINEDUSERCOUNT => {:type => ::Thrift::Types::I32, :name => 'joinedUserCount', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # This structure represents profile information for a user in a business.
# 
# <dl>
# <dt>id</dt>
# <dd>The numeric identifier that uniquely identifies a user.</dd>
# 
# <dt>name</dt>
# <dd>The full name of the user.</dd>
# 
# <dt>email</dt>
# <dd>The user's business email address. If the user has not registered their business
#   email address, this field will contain the user's personal email address.
# </dd>
# 
# <dt>username</dt>
# <dd>The user's Evernote username.</dd>
# 
# <dt>attributes</dt>
# <dd>The user's business specific attributes.</dd>
# 
# <dt>joined</dt>
# <dd>The time when the user joined the business</dd>
# 
# <dt>photoLastUpdated</dt>
# <dd>The time when the user's profile photo was most recently updated</dd>
# 
# <dt>photoUrl</dt>
# <dd>A URL identifying a copy of the user's current profile photo</dd>
# 
# <dt>role</dt>
# <dd>The BusinessUserRole for the user</dd>
# 
# </dl>
      class UserProfile
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ID = 1
        NAME = 2
        EMAIL = 3
        USERNAME = 4
        ATTRIBUTES = 5
        JOINED = 6
        PHOTOLASTUPDATED = 7
        PHOTOURL = 8
        ROLE = 9

        FIELDS = {
          ID => {:type => ::Thrift::Types::I32, :name => 'id', :optional => true},
          NAME => {:type => ::Thrift::Types::STRING, :name => 'name', :optional => true},
          EMAIL => {:type => ::Thrift::Types::STRING, :name => 'email', :optional => true},
          USERNAME => {:type => ::Thrift::Types::STRING, :name => 'username', :optional => true},
          ATTRIBUTES => {:type => ::Thrift::Types::STRUCT, :name => 'attributes', :class => ::Evernote::EDAM::Type::BusinessUserAttributes, :optional => true},
          JOINED => {:type => ::Thrift::Types::I64, :name => 'joined', :optional => true},
          PHOTOLASTUPDATED => {:type => ::Thrift::Types::I64, :name => 'photoLastUpdated', :optional => true},
          PHOTOURL => {:type => ::Thrift::Types::STRING, :name => 'photoUrl', :optional => true},
          ROLE => {:type => ::Thrift::Types::I32, :name => 'role', :optional => true, :enum_class => ::Evernote::EDAM::Type::BusinessUserRole}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @role.nil? || ::Evernote::EDAM::Type::BusinessUserRole::VALID_VALUES.include?(@role)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field role!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # An external image that can be shown with a related content snippet,
# usually either a JPEG or PNG image. It is up to the client which image(s) are shown,
# depending on available screen real estate, resolution and aspect ratio.
# 
# <dl>
#  <dt>url</dt>
#    <dd>The external URL of the image</dd>
#  <dt>width</dt>
#    <dd>The width of the image, in pixels.</dd>
#  <dt>height</dt>
#    <dd>The height of the image, in pixels.</dd>
#  <dt>pixelRatio</dt>
#    <dd>the pixel ratio (usually either 1.0, 1.5 or 2.0)</dd>
#  <dt>fileSize</dt>
#    <dd>the size of the image file, in bytes</dd>
# </dl>
      class RelatedContentImage
        include ::Thrift::Struct, ::Thrift::Struct_Union
        URL = 1
        WIDTH = 2
        HEIGHT = 3
        PIXELRATIO = 4
        FILESIZE = 5

        FIELDS = {
          URL => {:type => ::Thrift::Types::STRING, :name => 'url', :optional => true},
          WIDTH => {:type => ::Thrift::Types::I32, :name => 'width', :optional => true},
          HEIGHT => {:type => ::Thrift::Types::I32, :name => 'height', :optional => true},
          PIXELRATIO => {:type => ::Thrift::Types::DOUBLE, :name => 'pixelRatio', :optional => true},
          FILESIZE => {:type => ::Thrift::Types::I32, :name => 'fileSize', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A structure identifying one snippet of related content (some information that is not
# part of an Evernote account but might still be relevant to the user).
# 
# <dl>
# 
# <dt>contentId</dt>
# <dd>An identifier that uniquely identifies the content.</dd>
# 
# <dt>title</dt>
# <dd>The main title to show.</dd>
# 
# <dt>url</dt>
# <dd>The URL the client can use to retrieve the content.</dd>
# 
# <dt>sourceId</dt>
# <dd>An identifier that uniquely identifies the source.</dd>
# 
# <dt>sourceUrl</dt>
# <dd>A URL the client can access to know more about the source.</dd>
# 
# <dt>sourceFaviconUrl</dt>
# <dd>The favicon URL of the source which the content belongs to.</dd>
# </dl>
# 
# <dt>sourceName</dt>
# <dd>A human-readable name of the source that provided this content.</dd>
# 
# <dt>date</dt>
# <dd>A timestamp telling the user about the recency of the content.</dd>
# 
# <dt>teaser</dt>
# <dd>A teaser text to show to the user; usually the first few sentences of the content,
#     excluding the title.</dd>
# 
# <dt>thumbnails</dt>
# <dd>A list of thumbnails the client can show in the snippet.</dd>
# 
# <dt>contentType</dt>
# <dd>The type of this related content.</dd>
# 
# <dt>accessType</dt>
# <dd>An indication of how this content can be accessed. This type influences the
#     semantics of the <code>url</code> parameter.</dd>
# 
# <dt>visibleUrl</dt>
# <dd>If set, the client should show this URL to the user, instead of the URL that was
#     used to retrieve the content. This URL should be used when opening the content
#     in an external browser window, or when sharing with another person.</dd>
# 
# <dt>clipUrl</dt>
# <dd>If set, the client should use this URL for clipping purposes, instead of the URL
#     that was used to retrieve the content. The clipUrl may directly point to an .enex
#     file, for example.</dd>
# 
# <dt>contact</dt>
# <dd>If set, the client may use this Contact for messaging purposes. This will typically
#     only be set for user profiles.</dd>
# 
# <dt>authors</dt>
# <dd>For News articles only. A list of names of the article authors, if available.</dd>
# 
# </dl>
      class RelatedContent
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CONTENTID = 1
        TITLE = 2
        URL = 3
        SOURCEID = 4
        SOURCEURL = 5
        SOURCEFAVICONURL = 6
        SOURCENAME = 7
        DATE = 8
        TEASER = 9
        THUMBNAILS = 10
        CONTENTTYPE = 11
        ACCESSTYPE = 12
        VISIBLEURL = 13
        CLIPURL = 14
        CONTACT = 15
        AUTHORS = 16

        FIELDS = {
          CONTENTID => {:type => ::Thrift::Types::STRING, :name => 'contentId', :optional => true},
          TITLE => {:type => ::Thrift::Types::STRING, :name => 'title', :optional => true},
          URL => {:type => ::Thrift::Types::STRING, :name => 'url', :optional => true},
          SOURCEID => {:type => ::Thrift::Types::STRING, :name => 'sourceId', :optional => true},
          SOURCEURL => {:type => ::Thrift::Types::STRING, :name => 'sourceUrl', :optional => true},
          SOURCEFAVICONURL => {:type => ::Thrift::Types::STRING, :name => 'sourceFaviconUrl', :optional => true},
          SOURCENAME => {:type => ::Thrift::Types::STRING, :name => 'sourceName', :optional => true},
          DATE => {:type => ::Thrift::Types::I64, :name => 'date', :optional => true},
          TEASER => {:type => ::Thrift::Types::STRING, :name => 'teaser', :optional => true},
          THUMBNAILS => {:type => ::Thrift::Types::LIST, :name => 'thumbnails', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Evernote::EDAM::Type::RelatedContentImage}, :optional => true},
          CONTENTTYPE => {:type => ::Thrift::Types::I32, :name => 'contentType', :optional => true, :enum_class => ::Evernote::EDAM::Type::RelatedContentType},
          ACCESSTYPE => {:type => ::Thrift::Types::I32, :name => 'accessType', :optional => true, :enum_class => ::Evernote::EDAM::Type::RelatedContentAccess},
          VISIBLEURL => {:type => ::Thrift::Types::STRING, :name => 'visibleUrl', :optional => true},
          CLIPURL => {:type => ::Thrift::Types::STRING, :name => 'clipUrl', :optional => true},
          CONTACT => {:type => ::Thrift::Types::STRUCT, :name => 'contact', :class => ::Evernote::EDAM::Type::Contact, :optional => true},
          AUTHORS => {:type => ::Thrift::Types::LIST, :name => 'authors', :element => {:type => ::Thrift::Types::STRING}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @contentType.nil? || ::Evernote::EDAM::Type::RelatedContentType::VALID_VALUES.include?(@contentType)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field contentType!')
          end
          unless @accessType.nil? || ::Evernote::EDAM::Type::RelatedContentAccess::VALID_VALUES.include?(@accessType)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field accessType!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A structure describing an invitation to join a business account.
# 
# <dl>
#   <dt>businessId</dt>
#     <dd>
#       The ID of the business to which the invitation grants access.
#     </dd>
# 
#   <dt>email</dt>
#     <dd>
#       The email address that was invited to join the business.
#     </dd>
# 
#   <dt>role</dt>
#     <dd>
#       The role to grant the user after the invitation is accepted.
#     </dd>
# 
#   <dt>status</dt>
#     <dd>
#       The status of the invitation.
#     </dd>
# 
#   <dt>requesterId</dt>
#     <dd>
#       For invitations that were initially requested by a non-admin member of the business,
#       this field specifies the user ID of the requestor. For all other invitations, this field
#       will be unset.
#     </dd>
#   <dt>fromWorkChat</dt>
#     <dd>
#       If this invitation was created implicitly via a WorkChat, this field
#       will be true.
#     </dd>
#   <dt>created</dt>
#     <dd>
#       The timestamp at which this invitation was created.
#     </dd>
# </dl>
      class BusinessInvitation
        include ::Thrift::Struct, ::Thrift::Struct_Union
        BUSINESSID = 1
        EMAIL = 2
        ROLE = 3
        STATUS = 4
        REQUESTERID = 5
        FROMWORKCHAT = 6
        CREATED = 7

        FIELDS = {
          BUSINESSID => {:type => ::Thrift::Types::I32, :name => 'businessId', :optional => true},
          EMAIL => {:type => ::Thrift::Types::STRING, :name => 'email', :optional => true},
          ROLE => {:type => ::Thrift::Types::I32, :name => 'role', :optional => true, :enum_class => ::Evernote::EDAM::Type::BusinessUserRole},
          STATUS => {:type => ::Thrift::Types::I32, :name => 'status', :optional => true, :enum_class => ::Evernote::EDAM::Type::BusinessInvitationStatus},
          REQUESTERID => {:type => ::Thrift::Types::I32, :name => 'requesterId', :optional => true},
          FROMWORKCHAT => {:type => ::Thrift::Types::BOOL, :name => 'fromWorkChat', :optional => true},
          CREATED => {:type => ::Thrift::Types::I64, :name => 'created', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @role.nil? || ::Evernote::EDAM::Type::BusinessUserRole::VALID_VALUES.include?(@role)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field role!')
          end
          unless @status.nil? || ::Evernote::EDAM::Type::BusinessInvitationStatus::VALID_VALUES.include?(@status)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field status!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A structure that holds user identifying information such as an
# email address, Evernote user ID, or an identifier from a 3rd party
# service.  An instance consists of a type and a value, where the
# value will be stored in one of the value fields depending upon the
# data type required for the identity type.
# 
# When used with shared notebook invitations, a UserIdentity
# identifies a particular person who may not (yet) have an Evernote
# UserID UserIdentity but who has (almost) unique access to the
# service endpoint described by the UserIdentity.  For example, an
# e-mail UserIdentity can identify the person who receives e-mail at
# the given address, and who can therefore read the share key that
# has a cryptographic signature from the Evernote service. With the
# share key, this person can supply their Evernote UserID via an
# authentication token to join the notebook
# (authenticateToSharedNotebook), at which time we have associated
# the e-mail UserIdentity with an Evernote UserID UserIdentity. Note
# that using shared notebook records, the relationship between
# Evernote UserIDs and e-mail addresses is many to many.
# 
# Note that the identifier may not directly identify a
# particular Evernote UserID UserIdentity without further
# verification.  For example, an e-mail UserIdentity may be
# associated with an invitation to join a notebook (via a shared
# notebook record), but until a user uses a share key, that was sent
# to that e-mail address, to join the notebook, we do not know an
# Evernote UserID UserIdentity ID to match the e-mail address.
      class UserIdentity
        include ::Thrift::Struct, ::Thrift::Struct_Union
        TYPE = 1
        STRINGIDENTIFIER = 2
        LONGIDENTIFIER = 3

        FIELDS = {
          TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :optional => true, :enum_class => ::Evernote::EDAM::Type::UserIdentityType},
          STRINGIDENTIFIER => {:type => ::Thrift::Types::STRING, :name => 'stringIdentifier', :optional => true},
          LONGIDENTIFIER => {:type => ::Thrift::Types::I64, :name => 'longIdentifier', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @type.nil? || ::Evernote::EDAM::Type::UserIdentityType::VALID_VALUES.include?(@type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Records information related to a subscription which has been purchased by a user
# on a non-cancelable service such as iTunes - but which is not the active subscription
# (one tracked in accounting) because the user also has purchased a subscription at a
# higher service level.
# 
# <dl>
# <dt>subscriptionId</dt>
#     <dd>Unique id of noncancelable subscription</dd>
# <dt>user</dt>
#     <dd>User that owns the subscription</dd>
# <dt>premiumServiceStatus</dt>
#     <dd>Current state of subscription (active, canceled, etc).</dd>
# <dt>premiumCommerceService</dt>
#     <dd>One of the noncancelable services (currently either iTunes or Amazon)</dd>
# <dt>itunesReceiptData</dt>
#     <dd>For an iTunes subscription, contains the encoded data of the receipt. It is
#     required information for obtaining a subscription update from iTunes.</dd>
# <dt>amazonUserId</dt>
#     <dd>For an amazon subscription, the amazon user id. Required information for
#     obtaining a subscription update from amazon.</dd>
# <dt>amazonPurchaseToken</dt>
#     <dd>For an amazon subscription, the amazon purchase token. Required information for
#     obtaining a subscription update from amazon.</dd>
# <dt>premiumServiceSku</dt>
#     <dd>The sku purchased for this subscription. Identifies time period and service
#     level.</dd>
# <dt>nextPaymentDue</dt>
#     <dd>Date which subscription should renew. Used by commerce logic as date to check
#     for a subscription update from the service.</dd>
# <dt>premiumLockUntil</dt>
#     <dd>Allows for locking operations.</dd>
# <dt>unitPrice</dt>
#     <dd>Unit price for backup payment charge.</dd>
# <dt>currency</dt>
#     <dd>Currency of payment</dd>
# <dt>unitPrice</dt>
#     <dd>Charge in smallest unit of currency</dd>
# <dt>itunesOriginalTransactionId</dt>
#     <dd>For an iTunes subscription, contains the original transaction id as obtained
#     from any transaction record in the decoded receipt pertaining to this
#     non-cancelable subscription.</dd>
# </dl>
      class NoncancelableSubscription
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUBSCRIPTIONID = 1
        USER = 2
        PREMIUMSERVICESTATUS = 3
        PREMIUMCOMMERCESERVICE = 4
        ITUNESRECEIPTDATA = 5
        AMAZONUSERID = 6
        AMAZONPURCHASETOKEN = 7
        PREMIUMSERVICESKU = 8
        NEXTPAYMENTDUE = 9
        PREMIUMLOCKUNTIL = 10
        CURRENCY = 11
        UNITPRICE = 12
        ITUNESORIGINALTRANSACTIONID = 13

        FIELDS = {
          SUBSCRIPTIONID => {:type => ::Thrift::Types::I32, :name => 'subscriptionId'},
          USER => {:type => ::Thrift::Types::STRUCT, :name => 'user', :class => ::Evernote::EDAM::Type::User, :optional => true},
          PREMIUMSERVICESTATUS => {:type => ::Thrift::Types::I32, :name => 'premiumServiceStatus', :optional => true, :enum_class => ::Evernote::EDAM::Type::PremiumOrderStatus},
          PREMIUMCOMMERCESERVICE => {:type => ::Thrift::Types::STRING, :name => 'premiumCommerceService', :optional => true},
          ITUNESRECEIPTDATA => {:type => ::Thrift::Types::STRING, :name => 'itunesReceiptData', :optional => true},
          AMAZONUSERID => {:type => ::Thrift::Types::STRING, :name => 'amazonUserId', :optional => true},
          AMAZONPURCHASETOKEN => {:type => ::Thrift::Types::STRING, :name => 'amazonPurchaseToken', :optional => true},
          PREMIUMSERVICESKU => {:type => ::Thrift::Types::STRING, :name => 'premiumServiceSku', :optional => true},
          NEXTPAYMENTDUE => {:type => ::Thrift::Types::I64, :name => 'nextPaymentDue', :optional => true},
          PREMIUMLOCKUNTIL => {:type => ::Thrift::Types::I64, :name => 'premiumLockUntil', :optional => true},
          CURRENCY => {:type => ::Thrift::Types::STRING, :name => 'currency', :optional => true},
          UNITPRICE => {:type => ::Thrift::Types::I32, :name => 'unitPrice', :optional => true},
          ITUNESORIGINALTRANSACTIONID => {:type => ::Thrift::Types::STRING, :name => 'itunesOriginalTransactionId', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field subscriptionId is unset!') unless @subscriptionId
          unless @premiumServiceStatus.nil? || ::Evernote::EDAM::Type::PremiumOrderStatus::VALID_VALUES.include?(@premiumServiceStatus)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field premiumServiceStatus!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

    end
  end
end
