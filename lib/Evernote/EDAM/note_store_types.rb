#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require 'user_store_types'
require 'types_types'
require 'errors_types'
require 'limits_types'


module Evernote
  module EDAM
    module NoteStore
      #  This structure encapsulates the information about the state of the
#  user's account for the purpose of "state based" synchronization.
# <dl>
#  <dt>currentTime</dt>
#    <dd>
#    The server's current date and time.
#    </dd>
# 
#  <dt>fullSyncBefore</dt>
#    <dd>
#    The cutoff date and time for client caches to be
#    updated via incremental synchronization.  Any clients that were last
#    synched with the server before this date/time must do a full resync of all
#    objects.  This cutoff point will change over time as archival data is
#    deleted or special circumstances on the service require resynchronization.
#    </dd>
# 
#  <dt>updateCount</dt>
#    <dd>
#    Indicates the total number of transactions that have
#    been committed within the account.  This reflects (for example) the
#    number of discrete additions or modifications that have been made to
#    the data in this account (tags, notes, resources, etc.).
#    This number is the "high water mark" for Update Sequence Numbers (USN)
#    within the account.
#    </dd>
# 
#  <dt>uploaded</dt>
#    <dd>
#    The total number of bytes that have been uploaded to
#    this account in the current monthly period.  This can be compared against
#    Accounting.uploadLimit (from the UserStore) to determine how close the user
#    is to their monthly upload limit.
#    This value may not be present if the SyncState has been retrieved by
#    a caller that only has read access to the account.
#    </dd>
#  </dl>
      class SyncState
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CURRENTTIME = 1
        FULLSYNCBEFORE = 2
        UPDATECOUNT = 3
        UPLOADED = 4

        FIELDS = {
          CURRENTTIME => {:type => ::Thrift::Types::I64, :name => 'currentTime'},
          FULLSYNCBEFORE => {:type => ::Thrift::Types::I64, :name => 'fullSyncBefore'},
          UPDATECOUNT => {:type => ::Thrift::Types::I32, :name => 'updateCount'},
          UPLOADED => {:type => ::Thrift::Types::I64, :name => 'uploaded', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field currentTime is unset!') unless @currentTime
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field fullSyncBefore is unset!') unless @fullSyncBefore
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field updateCount is unset!') unless @updateCount
        end

        ::Thrift::Struct.generate_accessors self
      end

      #  This structure is given out by the NoteStore when a client asks to
#  receive the current state of an account.  The client asks for the server's
#  state one chunk at a time in order to allow clients to retrieve the state
#  of a large account without needing to transfer the entire account in
#  a single message.
# 
#  The server always gives SyncChunks using an ascending series of Update
#  Sequence Numbers (USNs).
# 
# <dl>
#  <dt>currentTime</dt>
#    <dd>
#    The server's current date and time.
#    </dd>
# 
#  <dt>chunkHighUSN</dt>
#    <dd>
#    The highest USN for any of the data objects represented
#    in this sync chunk.  If there are no objects in the chunk, this will not be
#    set.
#    </dd>
# 
#  <dt>updateCount</dt>
#    <dd>
#    The total number of updates that have been performed in
#    the service for this account.  This is equal to the highest USN within the
#    account at the point that this SyncChunk was generated.  If updateCount
#    and chunkHighUSN are identical, that means that this is the last chunk
#    in the account ... there is no more recent information.
#    </dd>
# 
#  <dt>notes</dt>
#    <dd>
#    If present, this is a list of non-expunged notes that
#    have a USN in this chunk.  This will include notes that are "deleted"
#    but not expunged (i.e. in the trash).  The notes will include their list
#    of tags and resources, but the resource content and recognition data
#    will not be supplied.
#    </dd>
# 
#  <dt>notebooks</dt>
#    <dd>
#    If present, this is a list of non-expunged notebooks that
#    have a USN in this chunk.  This will include notebooks that are "deleted"
#    but not expunged (i.e. in the trash).
#    </dd>
# 
#  <dt>tags</dt>
#    <dd>
#    If present, this is a list of the non-expunged tags that have a
#    USN in this chunk.
#    </dd>
# 
#  <dt>searches</dt>
#    <dd>
#    If present, this is a list of non-expunged searches that
#    have a USN in this chunk.
#    </dd>
# 
#  <dt>resources</dt>
#    <dd>
#    If present, this is a list of the non-expunged resources
#    that have a USN in this chunk.  This will include the metadata for each
#    resource, but not its binary contents or recognition data, which must be
#    retrieved separately.
#    </dd>
# 
#  <dt>expungedNotes</dt>
#    <dd>
#    If present, the GUIDs of all of the notes that were
#    permanently expunged in this chunk.
#    </dd>
# 
#  <dt>expungedNotebooks</dt>
#    <dd>
#    If present, the GUIDs of all of the notebooks that
#    were permanently expunged in this chunk.  When a notebook is expunged,
#    this implies that all of its child notes (and their resources) were
#    also expunged.
#    </dd>
# 
#  <dt>expungedTags</dt>
#    <dd>
#    If present, the GUIDs of all of the tags that were
#    permanently expunged in this chunk.
#    </dd>
# 
#  <dt>expungedSearches</dt>
#    <dd>
#    If present, the GUIDs of all of the saved searches
#    that were permanently expunged in this chunk.
#    </dd>
# 
#  <dt>linkedNotebooks</dt>
#    <dd>
#    If present, this is a list of non-expunged LinkedNotebooks that
#    have a USN in this chunk.
#    </dd>
# 
#  <dt>expungedLinkedNotebooks</dt>
#    <dd>
#    If present, the GUIDs of all of the LinkedNotebooks
#    that were permanently expunged in this chunk.
#    </dd>
#  </dl>
      class SyncChunk
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CURRENTTIME = 1
        CHUNKHIGHUSN = 2
        UPDATECOUNT = 3
        NOTES = 4
        NOTEBOOKS = 5
        TAGS = 6
        SEARCHES = 7
        RESOURCES = 8
        EXPUNGEDNOTES = 9
        EXPUNGEDNOTEBOOKS = 10
        EXPUNGEDTAGS = 11
        EXPUNGEDSEARCHES = 12
        LINKEDNOTEBOOKS = 13
        EXPUNGEDLINKEDNOTEBOOKS = 14

        FIELDS = {
          CURRENTTIME => {:type => ::Thrift::Types::I64, :name => 'currentTime'},
          CHUNKHIGHUSN => {:type => ::Thrift::Types::I32, :name => 'chunkHighUSN', :optional => true},
          UPDATECOUNT => {:type => ::Thrift::Types::I32, :name => 'updateCount'},
          NOTES => {:type => ::Thrift::Types::LIST, :name => 'notes', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Evernote::EDAM::Type::Note}, :optional => true},
          NOTEBOOKS => {:type => ::Thrift::Types::LIST, :name => 'notebooks', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Evernote::EDAM::Type::Notebook}, :optional => true},
          TAGS => {:type => ::Thrift::Types::LIST, :name => 'tags', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Evernote::EDAM::Type::Tag}, :optional => true},
          SEARCHES => {:type => ::Thrift::Types::LIST, :name => 'searches', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Evernote::EDAM::Type::SavedSearch}, :optional => true},
          RESOURCES => {:type => ::Thrift::Types::LIST, :name => 'resources', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Evernote::EDAM::Type::Resource}, :optional => true},
          EXPUNGEDNOTES => {:type => ::Thrift::Types::LIST, :name => 'expungedNotes', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          EXPUNGEDNOTEBOOKS => {:type => ::Thrift::Types::LIST, :name => 'expungedNotebooks', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          EXPUNGEDTAGS => {:type => ::Thrift::Types::LIST, :name => 'expungedTags', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          EXPUNGEDSEARCHES => {:type => ::Thrift::Types::LIST, :name => 'expungedSearches', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          LINKEDNOTEBOOKS => {:type => ::Thrift::Types::LIST, :name => 'linkedNotebooks', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Evernote::EDAM::Type::LinkedNotebook}, :optional => true},
          EXPUNGEDLINKEDNOTEBOOKS => {:type => ::Thrift::Types::LIST, :name => 'expungedLinkedNotebooks', :element => {:type => ::Thrift::Types::STRING}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field currentTime is unset!') unless @currentTime
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field updateCount is unset!') unless @updateCount
        end

        ::Thrift::Struct.generate_accessors self
      end

      #  This structure is used with the 'getFilteredSyncChunk' call to provide
#  fine-grained control over the data that's returned when a client needs
#  to synchronize with the service. Each flag in this structure specifies
#  whether to include one class of data in the results of that call.
# 
# <dl>
#  <dt>includeNotes</dt>
#    <dd>
#    If true, then the server will include the SyncChunks.notes field
#    </dd>
# 
#  <dt>includeNoteResources</dt>
#    <dd>
#    If true, then the server will include the 'resources' field on all of
#    the Notes that are in SyncChunk.notes.
#    If 'includeNotes' is false, then this will have no effect.
#    </dd>
# 
#  <dt>includeNoteAttributes</dt>
#    <dd>
#    If true, then the server will include the 'attributes' field on all of
#    the Notes that are in SyncChunks.notes.
#    If 'includeNotes' is false, then this will have no effect.
#    </dd>
# 
#  <dt>includeNotebooks</dt>
#    <dd>
#    If true, then the server will include the SyncChunks.notebooks field
#    </dd>
# 
#  <dt>includeTags</dt>
#    <dd>
#    If true, then the server will include the SyncChunks.tags field
#    </dd>
# 
#  <dt>includeSearches</dt>
#    <dd>
#    If true, then the server will include the SyncChunks.searches field
#    </dd>
# 
#  <dt>includeResources</dt>
#    <dd>
#    If true, then the server will include the SyncChunks.resources field.
#    Since the Resources are also provided with their Note
#    (in the Notes.resources list), this is primarily useful for clients that
#    want to watch for changes to individual Resources due to recognition data
#    being added.
#    </dd>
# 
#  <dt>includeLinkedNotebooks</dt>
#    <dd>
#    If true, then the server will include the SyncChunks.linkedNotebooks field.
#    </dd>
# 
#  <dt>includeExpunged</dt>
#    <dd>
#    If true, then the server will include the 'expunged' data for any type
#    of included data.  For example, if 'includeTags' and 'includeExpunged'
#    are both true, then the SyncChunks.expungedTags field will be set with
#    the GUIDs of tags that have been expunged from the server.
#    </dd>
# 
#  <dt>includeNoteApplicationDataFullMap</dt>
#    <dd>
#    If true, then the values for the applicationData map will be filled
#    in, assuming notes and note attributes are being returned.  Otherwise,
#    only the keysOnly field will be filled in.
#    </dd>
# 
#  <dt>includeResourceApplicationDataFullMap</dt>
#    <dd>
#    If true, then the fullMap values for the applicationData map will be
#    filled in, assuming resources and resource attributes are being returned
#    (includeResources is true).  Otherwise, only the keysOnly field will be
#    filled in.
#    </dd>
# 
#  <dt>includeNoteResourceApplicationDataFullMap</dt>
#    <dd>
#    If true, then the fullMap values for the applicationData map will be
#    filled in for resources found inside of notes, assuming resources are
#    being returned in notes (includeNoteResources is true).  Otherwise,
#    only the keysOnly field will be filled in.
#    </dd>
# 
#  <dt>requireNoteContentClass</dt>
#    <dd>
#    If set, then only send notes whose content class matches this value.
#    The value can be a literal match or, if the last character is an
#    asterisk, a prefix match.
#    </dd>
#  </dl>
      class SyncChunkFilter
        include ::Thrift::Struct, ::Thrift::Struct_Union
        INCLUDENOTES = 1
        INCLUDENOTERESOURCES = 2
        INCLUDENOTEATTRIBUTES = 3
        INCLUDENOTEBOOKS = 4
        INCLUDETAGS = 5
        INCLUDESEARCHES = 6
        INCLUDERESOURCES = 7
        INCLUDELINKEDNOTEBOOKS = 8
        INCLUDEEXPUNGED = 9
        INCLUDENOTEAPPLICATIONDATAFULLMAP = 10
        INCLUDERESOURCEAPPLICATIONDATAFULLMAP = 12
        INCLUDENOTERESOURCEAPPLICATIONDATAFULLMAP = 13
        REQUIRENOTECONTENTCLASS = 11

        FIELDS = {
          INCLUDENOTES => {:type => ::Thrift::Types::BOOL, :name => 'includeNotes', :optional => true},
          INCLUDENOTERESOURCES => {:type => ::Thrift::Types::BOOL, :name => 'includeNoteResources', :optional => true},
          INCLUDENOTEATTRIBUTES => {:type => ::Thrift::Types::BOOL, :name => 'includeNoteAttributes', :optional => true},
          INCLUDENOTEBOOKS => {:type => ::Thrift::Types::BOOL, :name => 'includeNotebooks', :optional => true},
          INCLUDETAGS => {:type => ::Thrift::Types::BOOL, :name => 'includeTags', :optional => true},
          INCLUDESEARCHES => {:type => ::Thrift::Types::BOOL, :name => 'includeSearches', :optional => true},
          INCLUDERESOURCES => {:type => ::Thrift::Types::BOOL, :name => 'includeResources', :optional => true},
          INCLUDELINKEDNOTEBOOKS => {:type => ::Thrift::Types::BOOL, :name => 'includeLinkedNotebooks', :optional => true},
          INCLUDEEXPUNGED => {:type => ::Thrift::Types::BOOL, :name => 'includeExpunged', :optional => true},
          INCLUDENOTEAPPLICATIONDATAFULLMAP => {:type => ::Thrift::Types::BOOL, :name => 'includeNoteApplicationDataFullMap', :optional => true},
          INCLUDERESOURCEAPPLICATIONDATAFULLMAP => {:type => ::Thrift::Types::BOOL, :name => 'includeResourceApplicationDataFullMap', :optional => true},
          INCLUDENOTERESOURCEAPPLICATIONDATAFULLMAP => {:type => ::Thrift::Types::BOOL, :name => 'includeNoteResourceApplicationDataFullMap', :optional => true},
          REQUIRENOTECONTENTCLASS => {:type => ::Thrift::Types::STRING, :name => 'requireNoteContentClass', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      #  A list of criteria that are used to indicate which notes are desired from
#  the account.  This is used in queries to the NoteStore to determine
#  which notes should be retrieved.
# 
# <dl>
#  <dt>order</dt>
#    <dd>
#    The NoteSortOrder value indicating what criterion should be
#    used to sort the results of the filter.
#    </dd>
# 
#  <dt>ascending</dt>
#    <dd>
#    If true, the results will be ascending in the requested
#    sort order.  If false, the results will be descending.
#    </dd>
# 
#  <dt>words</dt>
#    <dd>
#    If present, a search query string that will filter the set of notes to be returned.
#    Accepts the full search grammar documented in the Evernote API Overview.
#    </dd>
# 
#  <dt>notebookGuid</dt>
#    <dd>
#    If present, the Guid of the notebook that must contain
#    the notes.
#    </dd>
# 
#  <dt>tagGuids</dt>
#    <dd>
#    If present, the list of tags (by GUID) that must be present
#    on the notes.
#    </dd>
# 
#  <dt>timeZone</dt>
#    <dd>
#    The zone ID for the user, which will be used to interpret
#    any dates or times in the queries that do not include their desired zone
#    information.
#    For example, if a query requests notes created "yesterday", this
#    will be evaluated from the provided time zone, if provided.
#    The format must be encoded as a standard zone ID such as
#    "America/Los_Angeles".
#    </dd>
# 
#  <dt>inactive</dt>
#    <dd>
#    If true, then only notes that are not active (i.e. notes in
#    the Trash) will be returned. Otherwise, only active notes will be returned.
#    There is no way to find both active and inactive notes in a single query.
#    </dd>
# 
#  <dt>emphasized</dt>
#    <dd>
#    If present, a search query string that may or may not influence the notes
#    to be returned, both in terms of coverage as well as of order. Think of it
#    as a wish list, not a requirement.
#    Accepts the full search grammar documented in the Evernote API Overview.
#    </dd>
#  </dl>
      class NoteFilter
        include ::Thrift::Struct, ::Thrift::Struct_Union
        ORDER = 1
        ASCENDING = 2
        WORDS = 3
        NOTEBOOKGUID = 4
        TAGGUIDS = 5
        TIMEZONE = 6
        INACTIVE = 7
        EMPHASIZED = 8

        FIELDS = {
          ORDER => {:type => ::Thrift::Types::I32, :name => 'order', :optional => true},
          ASCENDING => {:type => ::Thrift::Types::BOOL, :name => 'ascending', :optional => true},
          WORDS => {:type => ::Thrift::Types::STRING, :name => 'words', :optional => true},
          NOTEBOOKGUID => {:type => ::Thrift::Types::STRING, :name => 'notebookGuid', :optional => true},
          TAGGUIDS => {:type => ::Thrift::Types::LIST, :name => 'tagGuids', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          TIMEZONE => {:type => ::Thrift::Types::STRING, :name => 'timeZone', :optional => true},
          INACTIVE => {:type => ::Thrift::Types::BOOL, :name => 'inactive', :optional => true},
          EMPHASIZED => {:type => ::Thrift::Types::STRING, :name => 'emphasized', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      #  A small structure for returning a list of notes out of a larger set.
# 
# <dl>
#  <dt>startIndex</dt>
#    <dd>
#    The starting index within the overall set of notes.  This
#    is also the number of notes that are "before" this list in the set.
#    </dd>
# 
#  <dt>totalNotes</dt>
#    <dd>
#    The number of notes in the larger set.  This can be used
#    to calculate how many notes are "after" this note in the set.
#    (I.e.  remaining = totalNotes - (startIndex + notes.length)  )
#    </dd>
# 
#  <dt>notes</dt>
#    <dd>
#    The list of notes from this range.  The Notes will include all
#    metadata (attributes, resources, etc.), but will not include the ENML
#    content of the note or the binary contents of any resources.
#    </dd>
# 
#  <dt>stoppedWords</dt>
#    <dd>
#    If the NoteList was produced using a text based search
#    query that included words that are not indexed or searched by the service,
#    this will include a list of those ignored words.
#    </dd>
# 
#  <dt>searchedWords</dt>
#    <dd>
#    If the NoteList was produced using a text based search
#    query that included viable search words or quoted expressions, this will
#    include a list of those words.  Any stopped words will not be included
#    in this list.
#    </dd>
# 
#  <dt>updateCount</dt>
#    <dd>
#    Indicates the total number of transactions that have
#    been committed within the account.  This reflects (for example) the
#    number of discrete additions or modifications that have been made to
#    the data in this account (tags, notes, resources, etc.).
#    This number is the "high water mark" for Update Sequence Numbers (USN)
#    within the account.
#    </dd>
#  </dl>
      class NoteList
        include ::Thrift::Struct, ::Thrift::Struct_Union
        STARTINDEX = 1
        TOTALNOTES = 2
        NOTES = 3
        STOPPEDWORDS = 4
        SEARCHEDWORDS = 5
        UPDATECOUNT = 6

        FIELDS = {
          STARTINDEX => {:type => ::Thrift::Types::I32, :name => 'startIndex'},
          TOTALNOTES => {:type => ::Thrift::Types::I32, :name => 'totalNotes'},
          NOTES => {:type => ::Thrift::Types::LIST, :name => 'notes', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Evernote::EDAM::Type::Note}},
          STOPPEDWORDS => {:type => ::Thrift::Types::LIST, :name => 'stoppedWords', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          SEARCHEDWORDS => {:type => ::Thrift::Types::LIST, :name => 'searchedWords', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          UPDATECOUNT => {:type => ::Thrift::Types::I32, :name => 'updateCount', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field startIndex is unset!') unless @startIndex
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field totalNotes is unset!') unless @totalNotes
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field notes is unset!') unless @notes
        end

        ::Thrift::Struct.generate_accessors self
      end

      # This structure is used in the set of results returned by the
# findNotesMetadata function.  It represents the high-level information about
# a single Note, without some of the larger deep structure.  This allows
# for the information about a list of Notes to be returned relatively quickly
# with less marshalling and data transfer to remote clients.
# Most fields in this structure are identical to the corresponding field in
# the Note structure, with the exception of:
# 
# <dl>
# <dt>largestResourceMime</dt>
#   <dd>If set, then this will contain the MIME type of the largest Resource
#   (in bytes) within the Note.  This may be useful, for example, to choose
#   an appropriate icon or thumbnail to represent the Note.
#   </dd>
# 
# <dt>largestResourceSize</dt>
#  <dd>If set, this will contain the size of the largest Resource file, in
#  bytes, within the Note.  This may be useful, for example, to decide whether
#  to ask the server for a thumbnail to represent the Note.
#  </dd>
# </dl>
      class NoteMetadata
        include ::Thrift::Struct, ::Thrift::Struct_Union
        GUID = 1
        TITLE = 2
        CONTENTLENGTH = 5
        CREATED = 6
        UPDATED = 7
        UPDATESEQUENCENUM = 10
        NOTEBOOKGUID = 11
        TAGGUIDS = 12
        ATTRIBUTES = 14
        LARGESTRESOURCEMIME = 20
        LARGESTRESOURCESIZE = 21

        FIELDS = {
          GUID => {:type => ::Thrift::Types::STRING, :name => 'guid'},
          TITLE => {:type => ::Thrift::Types::STRING, :name => 'title', :optional => true},
          CONTENTLENGTH => {:type => ::Thrift::Types::I32, :name => 'contentLength', :optional => true},
          CREATED => {:type => ::Thrift::Types::I64, :name => 'created', :optional => true},
          UPDATED => {:type => ::Thrift::Types::I64, :name => 'updated', :optional => true},
          UPDATESEQUENCENUM => {:type => ::Thrift::Types::I32, :name => 'updateSequenceNum', :optional => true},
          NOTEBOOKGUID => {:type => ::Thrift::Types::STRING, :name => 'notebookGuid', :optional => true},
          TAGGUIDS => {:type => ::Thrift::Types::LIST, :name => 'tagGuids', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          ATTRIBUTES => {:type => ::Thrift::Types::STRUCT, :name => 'attributes', :class => ::Evernote::EDAM::Type::NoteAttributes, :optional => true},
          LARGESTRESOURCEMIME => {:type => ::Thrift::Types::STRING, :name => 'largestResourceMime', :optional => true},
          LARGESTRESOURCESIZE => {:type => ::Thrift::Types::I32, :name => 'largestResourceSize', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field guid is unset!') unless @guid
        end

        ::Thrift::Struct.generate_accessors self
      end

      #  This structure is returned from calls to the findNotesMetadata function to
#  give the high-level metadata about a subset of Notes that are found to
#  match a specified NoteFilter in a search.
# 
# <dl>
#  <dt>startIndex</dt>
#    <dd>
#    The starting index within the overall set of notes.  This
#    is also the number of notes that are "before" this list in the set.
#    </dd>
# 
#  <dt>totalNotes</dt>
#    <dd>
#    The number of notes in the larger set.  This can be used
#    to calculate how many notes are "after" this note in the set.
#    (I.e.  remaining = totalNotes - (startIndex + notes.length)  )
#    </dd>
# 
#  <dt>notes</dt>
#    <dd>
#    The list of metadata for Notes in this range.  The set of optional fields
#    that are set in each metadata structure will depend on the
#    NotesMetadataResultSpec provided by the caller when the search was
#    performed.  Only the 'guid' field will be guaranteed to be set in each
#    Note.
#    </dd>
# 
#  <dt>stoppedWords</dt>
#    <dd>
#    If the NoteList was produced using a text based search
#    query that included words that are not indexed or searched by the service,
#    this will include a list of those ignored words.
#    </dd>
# 
#  <dt>searchedWords</dt>
#    <dd>
#    If the NoteList was produced using a text based search
#    query that included viable search words or quoted expressions, this will
#    include a list of those words.  Any stopped words will not be included
#    in this list.
#    </dd>
# 
#  <dt>updateCount</dt>
#    <dd>
#    Indicates the total number of transactions that have
#    been committed within the account.  This reflects (for example) the
#    number of discrete additions or modifications that have been made to
#    the data in this account (tags, notes, resources, etc.).
#    This number is the "high water mark" for Update Sequence Numbers (USN)
#    within the account.
#    </dd>
#  </dl>
      class NotesMetadataList
        include ::Thrift::Struct, ::Thrift::Struct_Union
        STARTINDEX = 1
        TOTALNOTES = 2
        NOTES = 3
        STOPPEDWORDS = 4
        SEARCHEDWORDS = 5
        UPDATECOUNT = 6

        FIELDS = {
          STARTINDEX => {:type => ::Thrift::Types::I32, :name => 'startIndex'},
          TOTALNOTES => {:type => ::Thrift::Types::I32, :name => 'totalNotes'},
          NOTES => {:type => ::Thrift::Types::LIST, :name => 'notes', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Evernote::EDAM::NoteStore::NoteMetadata}},
          STOPPEDWORDS => {:type => ::Thrift::Types::LIST, :name => 'stoppedWords', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          SEARCHEDWORDS => {:type => ::Thrift::Types::LIST, :name => 'searchedWords', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          UPDATECOUNT => {:type => ::Thrift::Types::I32, :name => 'updateCount', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field startIndex is unset!') unless @startIndex
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field totalNotes is unset!') unless @totalNotes
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field notes is unset!') unless @notes
        end

        ::Thrift::Struct.generate_accessors self
      end

      # This structure is provided to the findNotesMetadata function to specify
# the subset of fields that should be included in each NoteMetadata element
# that is returned in the NotesMetadataList.
# Each field on this structure is a boolean flag that indicates whether the
# corresponding field should be included in the NoteMetadata structure when
# it is returned.  For example, if the 'includeTitle' field is set on this
# structure when calling findNotesMetadata, then each NoteMetadata in the
# list should have its 'title' field set.
# If one of the fields in this spec is not set, then it will be treated as
# 'false' by the server, so the default behavior is to include nothing in
# replies (but the mandatory GUID)
      class NotesMetadataResultSpec
        include ::Thrift::Struct, ::Thrift::Struct_Union
        INCLUDETITLE = 2
        INCLUDECONTENTLENGTH = 5
        INCLUDECREATED = 6
        INCLUDEUPDATED = 7
        INCLUDEUPDATESEQUENCENUM = 10
        INCLUDENOTEBOOKGUID = 11
        INCLUDETAGGUIDS = 12
        INCLUDEATTRIBUTES = 14
        INCLUDELARGESTRESOURCEMIME = 20
        INCLUDELARGESTRESOURCESIZE = 21

        FIELDS = {
          INCLUDETITLE => {:type => ::Thrift::Types::BOOL, :name => 'includeTitle', :optional => true},
          INCLUDECONTENTLENGTH => {:type => ::Thrift::Types::BOOL, :name => 'includeContentLength', :optional => true},
          INCLUDECREATED => {:type => ::Thrift::Types::BOOL, :name => 'includeCreated', :optional => true},
          INCLUDEUPDATED => {:type => ::Thrift::Types::BOOL, :name => 'includeUpdated', :optional => true},
          INCLUDEUPDATESEQUENCENUM => {:type => ::Thrift::Types::BOOL, :name => 'includeUpdateSequenceNum', :optional => true},
          INCLUDENOTEBOOKGUID => {:type => ::Thrift::Types::BOOL, :name => 'includeNotebookGuid', :optional => true},
          INCLUDETAGGUIDS => {:type => ::Thrift::Types::BOOL, :name => 'includeTagGuids', :optional => true},
          INCLUDEATTRIBUTES => {:type => ::Thrift::Types::BOOL, :name => 'includeAttributes', :optional => true},
          INCLUDELARGESTRESOURCEMIME => {:type => ::Thrift::Types::BOOL, :name => 'includeLargestResourceMime', :optional => true},
          INCLUDELARGESTRESOURCESIZE => {:type => ::Thrift::Types::BOOL, :name => 'includeLargestResourceSize', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      #  A data structure representing the number of notes for each notebook
#  and tag with a non-zero set of applicable notes.
# 
# <dl>
#  <dt>notebookCounts</dt>
#    <dd>
#    A mapping from the Notebook GUID to the number of
#    notes (from some selection) that are in the corresponding notebook.
#    </dd>
# 
#  <dt>tagCounts</dt>
#    <dd>
#    A mapping from the Tag GUID to the number of notes (from some
#    selection) that have the corresponding tag.
#    </dd>
# 
#  <dt>trashCount</dt>
#    <dd>
#    If this is set, then this is the number of notes that are in the trash.
#    If this is not set, then the number of notes in the trash hasn't been
#    reported.  (I.e. if there are no notes in the trash, this will be set
#    to 0.)
#    </dd>
#  </dl>
      class NoteCollectionCounts
        include ::Thrift::Struct, ::Thrift::Struct_Union
        NOTEBOOKCOUNTS = 1
        TAGCOUNTS = 2
        TRASHCOUNT = 3

        FIELDS = {
          NOTEBOOKCOUNTS => {:type => ::Thrift::Types::MAP, :name => 'notebookCounts', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I32}, :optional => true},
          TAGCOUNTS => {:type => ::Thrift::Types::MAP, :name => 'tagCounts', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I32}, :optional => true},
          TRASHCOUNT => {:type => ::Thrift::Types::I32, :name => 'trashCount', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Parameters that must be given to the NoteStore emailNote call. These allow
# the caller to specify the note to send, the recipient addresses, etc.
# 
# <dl>
#  <dt>guid</dt>
#    <dd>
#      If set, this must be the GUID of a note within the user's account that
#      should be retrieved from the service and sent as email.  If not set,
#      the 'note' field must be provided instead.
#    </dd>
# 
#  <dt>note</dt>
#    <dd>
#      If the 'guid' field is not set, this field must be provided, including
#      the full contents of the note note (and all of its Resources) to send.
#      This can be used for a Note that as not been created in the service,
#      for example by a local client with local notes.
#    </dd>
# 
#  <dt>toAddresses</dt>
#    <dd>
#      If provided, this should contain a list of the SMTP email addresses
#      that should be included in the "To:" line of the email.
#      Callers must specify at least one "to" or "cc" email address.
#    </dd>
# 
#  <dt>ccAddresses</dt>
#    <dd>
#      If provided, this should contain a list of the SMTP email addresses
#      that should be included in the "Cc:" line of the email.
#      Callers must specify at least one "to" or "cc" email address.
#    </dd>
# 
#  <dt>subject</dt>
#    <dd>
#      If provided, this should contain the subject line of the email that
#      will be sent.  If not provided, the title of the note will be used
#      as the subject of the email.
#    </dd>
# 
#  <dt>message</dt>
#    <dd>
#      If provided, this is additional personal text that should be included
#      into the email as a message from the owner to the recipient(s).
#    </dd>
# </dl>
      class NoteEmailParameters
        include ::Thrift::Struct, ::Thrift::Struct_Union
        GUID = 1
        NOTE = 2
        TOADDRESSES = 3
        CCADDRESSES = 4
        SUBJECT = 5
        MESSAGE = 6

        FIELDS = {
          GUID => {:type => ::Thrift::Types::STRING, :name => 'guid', :optional => true},
          NOTE => {:type => ::Thrift::Types::STRUCT, :name => 'note', :class => ::Evernote::EDAM::Type::Note, :optional => true},
          TOADDRESSES => {:type => ::Thrift::Types::LIST, :name => 'toAddresses', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          CCADDRESSES => {:type => ::Thrift::Types::LIST, :name => 'ccAddresses', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
          SUBJECT => {:type => ::Thrift::Types::STRING, :name => 'subject', :optional => true},
          MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Identifying information about previous versions of a note that are backed up
# within Evernote's servers.  Used in the return value of the listNoteVersions
# call.
# 
# <dl>
#  <dt>updateSequenceNum</dt>
#  <dd>
#    The update sequence number for the Note when it last had this content.
#    This serves to uniquely identify each version of the note, since USN
#    values are unique within an account for each update.
#  </dd>
#  <dt>updated</dt>
#  <dd>
#    The 'updated' time that was set on the Note when it had this version
#    of the content.  This is the user-modifiable modification time on the
#    note, so it's not reliable for guaranteeing the order of various
#    versions.  (E.g. if someone modifies the note, then changes this time
#    manually into the past and then updates the note again.)
#  </dd>
#  <dt>saved</dt>
#  <dd>
#    A timestamp that holds the date and time when this version of the note
#    was backed up by Evernote's servers.  This
#  </dd>
#  <dt>title</dt>
#  <dd>
#    The title of the note when this particular version was saved.  (The
#    current title of the note may differ from this value.)
#  </dd>
# </dl>
      class NoteVersionId
        include ::Thrift::Struct, ::Thrift::Struct_Union
        UPDATESEQUENCENUM = 1
        UPDATED = 2
        SAVED = 3
        TITLE = 4

        FIELDS = {
          UPDATESEQUENCENUM => {:type => ::Thrift::Types::I32, :name => 'updateSequenceNum'},
          UPDATED => {:type => ::Thrift::Types::I64, :name => 'updated'},
          SAVED => {:type => ::Thrift::Types::I64, :name => 'saved'},
          TITLE => {:type => ::Thrift::Types::STRING, :name => 'title'}
        }

        def struct_fields; FIELDS; end

        def validate
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field updateSequenceNum is unset!') unless @updateSequenceNum
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field updated is unset!') unless @updated
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field saved is unset!') unless @saved
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field title is unset!') unless @title
        end

        ::Thrift::Struct.generate_accessors self
      end

      # This structure is passed from clients to the Evernote service when they wish
# to relay coarse-grained usage metrics to the service to help improve
# products.
# 
# <dl>
#  <dt>sessions</dt>
#  <dd>
#    This field contains a count of the number of usage "sessions" that have
#    occurred with this client which have not previously been reported to
#    the service.
#    A "session" is defined as one of the 96 fifteen-minute intervals of the
#    day when someone used Evernote's interface at least once.
#    So if a user interacts with an Evernote client at 12:18, 12:24, and 12:36,
#    and then the client synchronizes at 12:39, it would report that there were
#    two previously-unreported sessions (one session for the 12:15-12:30 time
#    period, and one for the 12:30-12:45 period).
#    If the user used Evernote again at 12:41 and synchronized at 12:43, it
#    would not report any new sessions, because the 12:30-12:45 session had
#    already been reported.
#  </dd>
# </dl>
      class ClientUsageMetrics
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SESSIONS = 1

        FIELDS = {
          SESSIONS => {:type => ::Thrift::Types::I32, :name => 'sessions', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A description of the thing for which we are searching for related
# entities.
# 
# You must specify either <em>noteGuid</em> or <em>plainText</em>, but
# not both. <em>filter</em> is optional.
# 
# <dl>
# <dt>noteGuid</dt>
# <dd>The GUID of an existing note in your account for which related
#     entities will be found.</dd>
# 
# <dt>plainText</dt>
# <dd>A string of plain text for which to find related entities.
#     You should provide a text block with a number of characters between
#     EDAM_RELATED_PLAINTEXT_LEN_MIN and EDAM_RELATED_PLAINTEXT_LEN_MAX.
#     </dd>
# 
# <dt>filter</dt>
# <dd>The list of criteria that will constrain the notes being considered
#     related.
#     Please note that some of the parameters may be ignored, such as
#     <em>order</em> and <em>ascending</em>.
# </dd>
# </dl>
      class RelatedQuery
        include ::Thrift::Struct, ::Thrift::Struct_Union
        NOTEGUID = 1
        PLAINTEXT = 2
        FILTER = 3

        FIELDS = {
          NOTEGUID => {:type => ::Thrift::Types::STRING, :name => 'noteGuid', :optional => true},
          PLAINTEXT => {:type => ::Thrift::Types::STRING, :name => 'plainText', :optional => true},
          FILTER => {:type => ::Thrift::Types::STRUCT, :name => 'filter', :class => ::Evernote::EDAM::NoteStore::NoteFilter, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The result of calling findRelated().  The contents of the notes,
# notebooks, and tags fields will be in decreasing order of expected
# relevance.  It is possible that fewer results than requested will be
# returned even if there are enough distinct entities in the account
# in cases where the relevance is estimated to be low.
# 
# <dl>
# <dt>notes</dt>
# <dd>If notes have been requested to be included, this will be the
#     list of notes.</dd>
# 
# <dt>notebooks</dt>
# <dd>If notebooks have been requested to be included, this will be the
#     list of notebooks.</dd>
# 
# <dt>tags</dt>
# <dd>If tags have been requested to be included, this will be the list
#     of tags.</dd>
# </dl>
# 
# <dt>containingNotebooks</dt>
# <dd>If <code>includeContainingNotebooks</code> is set to <code>true</code>
#     in the RelatedResultSpec, return the list of notebooks to
#     to which the returned related notes belong. The notebooks in this
#     list will occur once per notebook GUID and are represented as
#     NotebookDescriptor objects.</dd>
# </dl>
# 
# <dt>debugInfo</dt>
# <dd>NOTE: This should be excluded from the public API.<br /><br />
#     If <code>includeDebugInfo</code> in RelatedResultSpec is set to
#     <code>true</code>, this field may contain debug information
#     if the service decides to do so.</dd>
# </dl>
      class RelatedResult
        include ::Thrift::Struct, ::Thrift::Struct_Union
        NOTES = 1
        NOTEBOOKS = 2
        TAGS = 3
        CONTAININGNOTEBOOKS = 4
        DEBUGINFO = 5

        FIELDS = {
          NOTES => {:type => ::Thrift::Types::LIST, :name => 'notes', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Evernote::EDAM::Type::Note}, :optional => true},
          NOTEBOOKS => {:type => ::Thrift::Types::LIST, :name => 'notebooks', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Evernote::EDAM::Type::Notebook}, :optional => true},
          TAGS => {:type => ::Thrift::Types::LIST, :name => 'tags', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Evernote::EDAM::Type::Tag}, :optional => true},
          CONTAININGNOTEBOOKS => {:type => ::Thrift::Types::LIST, :name => 'containingNotebooks', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Evernote::EDAM::Type::NotebookDescriptor}, :optional => true},
          DEBUGINFO => {:type => ::Thrift::Types::STRING, :name => 'debugInfo', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A description of the thing for which the service will find related
# entities, via findRelated(), together with a description of what
# type of entities and how many you are seeking in the
# RelatedResult.
# 
# <dl>
# <dt>maxNotes</dt>
# <dd>Return notes that are related to the query, but no more than
#     this many.  Any value greater than EDAM_RELATED_MAX_NOTES
#     will be silently capped.  If you do not set this field, then
#     no notes will be returned.</dd>
# 
# <dt>maxNotebooks</dt>
# <dd>Return notebooks that are related to the query, but no more than
#     this many.  Any value greater than EDAM_RELATED_MAX_NOTEBOOKS
#     will be silently capped.  If you do not set this field, then
#     no notebooks will be returned.</dd>
# 
# <dt>maxTags</dt>
# <dd>Return tags that are related to the query, but no more than
#     this many.  Any value greater than EDAM_RELATED_MAX_TAGS
#     will be silently capped.  If you do not set this field, then
#     no tags will be returned.</dd>
# </dl>
# 
# <dt>writableNotebooksOnly</dt>
# <dd>Require that all returned related notebooks are writable.
#     The user will be able to create notes in all returned notebooks.
#     However, individual notes returned may still belong to notebooks
#     in which the user lacks the ability to create notes.</dd>
# </dl>
# 
# <dt>includeContainingNotebooks</dt>
# <dd>If set to <code>true</code>, return the containingNotebooks field
#     in the RelatedResult, which will contain the list of notebooks to
#     to which the returned related notes belong.</dd>
# </dl>
# 
# <dt>includeDebugInfo</dt>
# <dd>NOTE: This should be excluded from the public API.<br /><br />
#     If set to <code>true</code>, indicate that debug information should
#     be returned in the 'debugInfo' field of RelatedResult.</dd>
# </dl>
      class RelatedResultSpec
        include ::Thrift::Struct, ::Thrift::Struct_Union
        MAXNOTES = 1
        MAXNOTEBOOKS = 2
        MAXTAGS = 3
        WRITABLENOTEBOOKSONLY = 4
        INCLUDECONTAININGNOTEBOOKS = 5
        INCLUDEDEBUGINFO = 6

        FIELDS = {
          MAXNOTES => {:type => ::Thrift::Types::I32, :name => 'maxNotes', :optional => true},
          MAXNOTEBOOKS => {:type => ::Thrift::Types::I32, :name => 'maxNotebooks', :optional => true},
          MAXTAGS => {:type => ::Thrift::Types::I32, :name => 'maxTags', :optional => true},
          WRITABLENOTEBOOKSONLY => {:type => ::Thrift::Types::BOOL, :name => 'writableNotebooksOnly', :optional => true},
          INCLUDECONTAININGNOTEBOOKS => {:type => ::Thrift::Types::BOOL, :name => 'includeContainingNotebooks', :optional => true},
          INCLUDEDEBUGINFO => {:type => ::Thrift::Types::BOOL, :name => 'includeDebugInfo', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

    end
  end
end
